<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于 CentOS 的 ISSO 评论系统后台搭建及修改全程记录</title>
    <link href="/2020/03/06/isso-config/"/>
    <url>/2020/03/06/isso-config/</url>
    
    <content type="html"><![CDATA[<p>此文用于记录蛋疼的 isso 评论系统配置过程。</p><a id="more"></a><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>1、安装基本环境</p><pre><code class="hljs bash">yum -y update &amp;&amp; yum install -y wget vim git make automake autoconf gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel libtool python3 python3-devel</code></pre><p>2、安装 nginx</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~ \    &amp;&amp; wget http://nginx.org/download/nginx-1.16.1.tar.gz \    &amp;&amp; tar -zxvf nginx-1.16.1.tar.gz \    &amp;&amp; <span class="hljs-built_in">cd</span> nginx-1.16.1 \    &amp;&amp; mkdir -p /usr/<span class="hljs-built_in">local</span>/nginx \    &amp;&amp; ./configure --prefix=/usr/<span class="hljs-built_in">local</span>/nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre \    &amp;&amp; make &amp;&amp; make install</code></pre><p>3、安装 nodejs</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~ \    &amp;&amp; wget https://nodejs.org/dist/v12.16.1/node-v12.16.1-linux-x64.tar.xz \    &amp;&amp; tar xvJf node-v12.16.1-linux-x64.tar.xz \    &amp;&amp; mv node-v12.16.1-linux-x64 /usr/<span class="hljs-built_in">local</span>/node</code></pre><p>4、清理压缩包</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~ \    &amp;&amp; rm -rf nginx-1.16.1 nginx-1.16.1.tar.gz \    &amp;&amp; rm -rf node-v12.16.1-linux-x64.tar.xz</code></pre><p>5、设置环境变量</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NGINX_HOME=/usr/<span class="hljs-built_in">local</span>/nginx<span class="hljs-built_in">export</span> NODE_HOME=/usr/<span class="hljs-built_in">local</span>/node<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$NGINX_HOME</span>/sbin:<span class="hljs-variable">$NODE_HOME</span>/bin:<span class="hljs-variable">$PATH</span></code></pre><h2 id="配置并运行-nginx"><a href="#配置并运行-nginx" class="headerlink" title="配置并运行 nginx"></a>配置并运行 nginx</h2><p>1、配置 nginx</p><pre><code class="hljs bash">vim /usr/<span class="hljs-built_in">local</span>/nginx/conf/nginx.conf</code></pre><p><strong>nginx.conf</strong> 文件内容：</p><pre><code class="hljs plain">#user  nobody;worker_processes  1;#error_log  logs&#x2F;error.log;#error_log  logs&#x2F;error.log  notice;#error_log  logs&#x2F;error.log  info;pid        logs&#x2F;nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs&#x2F;access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    upstream isso &#123;        server 127.0.0.1:11006;    &#125;    server &#123;        listen       5000;        server_name  localhost;        #charset koi8-r;        access_log  logs&#x2F;localhost.access.log;        error_log   logs&#x2F;localhost.error.log;        location &#x2F;isso &#123;            proxy_set_header X-Script-Name &#x2F;isso;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Scheme $scheme;            proxy_pass http:&#x2F;&#x2F;isso;        &#125;        #error_page  404              &#x2F;404.html;        # redirect server error pages to the static page &#x2F;50x.html        #        error_page   500 502 503 504  &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ &#123;        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;        #&#125;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ &#123;        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;        #    include        fastcgi_params;        #&#125;        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ &#x2F;\.ht &#123;        #    deny  all;        #&#125;    &#125;    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server &#123;    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location &#x2F; &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;    # HTTPS server    #    #server &#123;    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location &#x2F; &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;&#125;</code></pre><p>2、运行 nginx</p><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/nginx/sbin/nginx -c /usr/<span class="hljs-built_in">local</span>/nginx/conf/nginx.conf</code></pre><p>3、重启 nginx</p><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/nginx/sbin/nginx -s reload</code></pre><p>4、停止 nginx</p><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/nginx/sbin/nginx -s stop</code></pre><h2 id="安装-python-的-virtualenv-模块"><a href="#安装-python-的-virtualenv-模块" class="headerlink" title="安装 python 的 virtualenv 模块"></a>安装 python 的 virtualenv 模块</h2><pre><code class="hljs bash">pip3 install virtualenv</code></pre><h2 id="从源码安装-isso"><a href="#从源码安装-isso" class="headerlink" title="从源码安装 isso"></a>从源码安装 isso</h2><p>1、将 isso 从 github 克隆到本地</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/posativ/isso.git /usr/<span class="hljs-built_in">local</span>/isso<span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/isso</code></pre><p>2、建立 python3 虚拟环境</p><pre><code class="hljs bash">virtualenv .<span class="hljs-built_in">source</span> ./bin/activate</code></pre><p>3、安装必要 python 第三方库</p><pre><code class="hljs bash">pip install flask cffi webencodings six</code></pre><p>4、安装 isso</p><pre><code class="hljs bash">python setup.py develop</code></pre><p>5、使用 npm 安装 bower</p><pre><code class="hljs bash">npm install -g bower</code></pre><p>6、安装 javascript 模块</p><pre><code class="hljs bash">make init</code></pre><p>7、安装其他几个 js 工具</p><pre><code class="hljs bash">npm install -g requirejs uglify-js jade</code></pre><p>8、修改 isso 源码，以修改即将生成的 <strong>embed.min.js</strong> 文件的内容，实现隐藏 website 输入框、preview 按钮、 edit 按钮以及 preview 界面的目的</p><pre><code class="hljs bash">vim isso/js/app/text/postbox.jade</code></pre><p>为需要修改的部分添加 <code>style={display: &#39;none&#39;}</code> 字符串以隐藏该元素。</p><p><strong>isso/js/app/text/postbox.jade</strong> 文件内容如下：</p><pre><code class="hljs plain">div(class&#x3D;&#39;isso-postbox&#39;)    div(class&#x3D;&#39;form-wrapper&#39;)        div(class&#x3D;&#39;textarea-wrapper&#39;)            div(class&#x3D;&#39;textarea placeholder&#39; contenteditable&#x3D;&#39;true&#39;)                &#x3D; i18n(&#39;postbox-text&#39;)            div(class&#x3D;&#39;preview&#39; style&#x3D;&#123;display: &#39;none&#39;&#125;)                div(class&#x3D;&#39;isso-comment&#39;)                    div(class&#x3D;&#39;text-wrapper&#39;)                        div(class&#x3D;&#39;text&#39;)        section(class&#x3D;&#39;auth-section&#39;)            p(class&#x3D;&#39;input-wrapper&#39;)                input(type&#x3D;&#39;text&#39; name&#x3D;&#39;author&#39; placeholder&#x3D;i18n(&#39;postbox-author&#39;)                      value&#x3D;author !&#x3D;&#x3D; null ? &#39;#&#123;author&#125;&#39; : &#39;&#39;)            p(class&#x3D;&#39;input-wrapper&#39;)                input(type&#x3D;&#39;email&#39; name&#x3D;&#39;email&#39; placeholder&#x3D;i18n(&#39;postbox-email&#39;)                      value&#x3D;email !&#x3D; null ? &#39;#&#123;email&#125;&#39; : &#39;&#39;)            p(class&#x3D;&#39;input-wrapper&#39; style&#x3D;&#123;display: &#39;none&#39;&#125;)                input(type&#x3D;&#39;text&#39; name&#x3D;&#39;website&#39; placeholder&#x3D;i18n(&#39;postbox-website&#39;)                      value&#x3D;website !&#x3D; null ? &#39;#&#123;website&#125;&#39; : &#39;&#39;)            p(class&#x3D;&#39;post-action&#39;)                input(type&#x3D;&#39;submit&#39; value&#x3D;i18n(&#39;postbox-submit&#39;))            p(class&#x3D;&#39;post-action&#39; style&#x3D;&#123;display: &#39;none&#39;&#125;)                input(type&#x3D;&#39;button&#39; name&#x3D;&#39;preview&#39;                      value&#x3D;i18n(&#39;postbox-preview&#39;))            p(class&#x3D;&#39;post-action&#39; style&#x3D;&#123;display: &#39;none&#39;&#125;)                input(type&#x3D;&#39;button&#39; name&#x3D;&#39;edit&#39;                      value&#x3D;i18n(&#39;postbox-edit&#39;))        section(class&#x3D;&#39;notification-section&#39;)                label                    input(type&#x3D;&#39;checkbox&#39; name&#x3D;&#39;notification&#39;)                    &#x3D; i18n(&#39;postbox-notification&#39;)</code></pre><p>9、为 isso 添加配置文件 (<a href="https://posativ.org/isso/docs/configuration/server/" target="_blank" rel="noopener">文档</a>)</p><pre><code class="hljs bash">vim /etc/isso.conf</code></pre><p><strong>isso.conf</strong> 文件内容如下：</p><pre><code class="hljs plain">[general]dbpath &#x3D; &#x2F;var&#x2F;lib&#x2F;isso&#x2F;comments.dbhost &#x3D; http:&#x2F;&#x2F;localhost:4000&#x2F;[server]listen &#x3D; http:&#x2F;&#x2F;localhost:11006&#x2F;</code></pre><p>10、创建文件夹</p><pre><code class="hljs bash">mkdir -p /var/lib/isso</code></pre><p>11、生成 js 文件</p><pre><code class="hljs bash">make js</code></pre><p>12、运行 isso</p><pre><code class="hljs bash">bin/isso -c /etc/isso.conf</code></pre><h2 id="使用-supervisor-管理-isso"><a href="#使用-supervisor-管理-isso" class="headerlink" title="使用 supervisor 管理 isso"></a>使用 supervisor 管理 isso</h2><p>1、使用 pip 工具安装 supervisor</p><pre><code class="hljs bash">pip3 install supervisor</code></pre><p>2、创建文件夹</p><pre><code class="hljs bash">mkdir -p /etc/supervisor/conf.dmkdir -p /var/<span class="hljs-built_in">log</span>/isso</code></pre><p>3、编写 supervisor 主配置文件</p><pre><code class="hljs bash">vim /etc/supervisor/supervisord.conf</code></pre><p><strong>supervisord.conf</strong> 文件的内容如下：</p><pre><code class="hljs plain">; Sample supervisor config file.;; For more information on the config file, please see:; http:&#x2F;&#x2F;supervisord.org&#x2F;configuration.html;; Notes:;  - Shell expansion (&quot;~&quot; or &quot;$HOME&quot;) is not supported.  Environment;    variables can be expanded using this syntax: &quot;%(ENV_HOME)s&quot;.;  - Quotes around values are not supported, except in the case of;    the environment&#x3D; options as shown below.;  - Comments must have a leading space: &quot;a&#x3D;b ;comment&quot; not &quot;a&#x3D;b;comment&quot;.;  - Command will be truncated if it looks like a config file comment, e.g.;    &quot;command&#x3D;bash -c &#39;foo ; bar&#39;&quot; will truncate to &quot;command&#x3D;bash -c &#39;foo &quot;.;; Warning:;  Paths throughout this example file use &#x2F;tmp because it is available on most;  systems.  You will likely need to change these to locations more appropriate;  for your system.  Some systems periodically delete older files in &#x2F;tmp.;  Notably, if the socket file defined in the [unix_http_server] section below;  is deleted, supervisorctl will be unable to connect to supervisord.[unix_http_server]file&#x3D;&#x2F;tmp&#x2F;supervisor.sock   ; the path to the socket file;chmod&#x3D;0700                 ; socket file mode (default 0700);chown&#x3D;nobody:nogroup       ; socket file uid:gid owner;username&#x3D;user              ; default is no username (open server);password&#x3D;123               ; default is no password (open server); Security Warning:;  The inet HTTP server is not enabled by default.  The inet HTTP server is;  enabled by uncommenting the [inet_http_server] section below.  The inet;  HTTP server is intended for use within a trusted environment only.  It;  should only be bound to localhost or only accessible from within an;  isolated, trusted network.  The inet HTTP server does not support any;  form of encryption.  The inet HTTP server does not use authentication;  by default (see the username&#x3D; and password&#x3D; options to add authentication).;  Never expose the inet HTTP server to the public internet.;[inet_http_server]         ; inet (TCP) server disabled by default;port&#x3D;127.0.0.1:9001        ; ip_address:port specifier, *:port for all iface;username&#x3D;user              ; default is no username (open server);password&#x3D;123               ; default is no password (open server)[supervisord]logfile&#x3D;&#x2F;tmp&#x2F;supervisord.log ; main log file; default $CWD&#x2F;supervisord.loglogfile_maxbytes&#x3D;50MB        ; max main logfile bytes b4 rotation; default 50MBlogfile_backups&#x3D;10           ; # of main logfile backups; 0 means none, default 10loglevel&#x3D;info                ; log level; default info; others: debug,warn,tracepidfile&#x3D;&#x2F;tmp&#x2F;supervisord.pid ; supervisord pidfile; default supervisord.pidnodaemon&#x3D;false               ; start in foreground if true; default falseminfds&#x3D;1024                  ; min. avail startup file descriptors; default 1024minprocs&#x3D;200                 ; min. avail process descriptors;default 200;umask&#x3D;022                   ; process file creation umask; default 022;user&#x3D;supervisord            ; setuid to this UNIX account at startup; recommended if root;identifier&#x3D;supervisor       ; supervisord identifier, default is &#39;supervisor&#39;;directory&#x3D;&#x2F;tmp              ; default is not to cd during start;nocleanup&#x3D;true              ; don&#39;t clean up tempfiles at start; default false;childlogdir&#x3D;&#x2F;tmp            ; &#39;AUTO&#39; child log dir, default $TEMP;environment&#x3D;KEY&#x3D;&quot;value&quot;     ; key value pairs to add to environment;strip_ansi&#x3D;false            ; strip ansi escape codes in logs; def. false; The rpcinterface:supervisor section must remain in the config file for; RPC (supervisorctl&#x2F;web interface) to work.  Additional interfaces may be; added by defining them in separate [rpcinterface:x] sections.[rpcinterface:supervisor]supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface; The supervisorctl section configures how supervisorctl will connect to; supervisord.  configure it match the settings in either the unix_http_server; or inet_http_server section.[supervisorctl]serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket;serverurl&#x3D;http:&#x2F;&#x2F;127.0.0.1:9001 ; use an http:&#x2F;&#x2F; url to specify an inet socket;username&#x3D;chris              ; should be same as in [*_http_server] if set;password&#x3D;123                ; should be same as in [*_http_server] if set;prompt&#x3D;mysupervisor         ; cmd line prompt (default &quot;supervisor&quot;);history_file&#x3D;~&#x2F;.sc_history  ; use readline history if available; The sample program section below shows all possible program subsection values.; Create one or more &#39;real&#39; program: sections to be able to control them under; supervisor.;[program:theprogramname];command&#x3D;&#x2F;bin&#x2F;cat              ; the program (relative uses PATH, can take args);process_name&#x3D;%(program_name)s ; process_name expr (default %(program_name)s);numprocs&#x3D;1                    ; number of processes copies to start (def 1);directory&#x3D;&#x2F;tmp                ; directory to cwd to before exec (def no cwd);umask&#x3D;022                     ; umask for process (default None);priority&#x3D;999                  ; the relative start priority (default 999);autostart&#x3D;true                ; start at supervisord start (default: true);startsecs&#x3D;1                   ; # of secs prog must stay up to be running (def. 1);startretries&#x3D;3                ; max # of serial start failures when starting (default 3);autorestart&#x3D;unexpected        ; when to restart if exited after running (def: unexpected);exitcodes&#x3D;0                   ; &#39;expected&#39; exit codes used with autorestart (default 0);stopsignal&#x3D;QUIT               ; signal used to kill process (default TERM);stopwaitsecs&#x3D;10               ; max num secs to wait b4 SIGKILL (default 10);stopasgroup&#x3D;false             ; send stop signal to the UNIX process group (default false);killasgroup&#x3D;false             ; SIGKILL the UNIX process group (def false);user&#x3D;chrism                   ; setuid to this UNIX account to run the program;redirect_stderr&#x3D;true          ; redirect proc stderr to stdout (default false);stdout_logfile&#x3D;&#x2F;a&#x2F;path        ; stdout log path, NONE for none; default AUTO;stdout_logfile_maxbytes&#x3D;1MB   ; max # logfile bytes b4 rotation (default 50MB);stdout_logfile_backups&#x3D;10     ; # of stdout logfile backups (0 means none, default 10);stdout_capture_maxbytes&#x3D;1MB   ; number of bytes in &#39;capturemode&#39; (default 0);stdout_events_enabled&#x3D;false   ; emit events on stdout writes (default false);stdout_syslog&#x3D;false           ; send stdout to syslog with process name (default false);stderr_logfile&#x3D;&#x2F;a&#x2F;path        ; stderr log path, NONE for none; default AUTO;stderr_logfile_maxbytes&#x3D;1MB   ; max # logfile bytes b4 rotation (default 50MB);stderr_logfile_backups&#x3D;10     ; # of stderr logfile backups (0 means none, default 10);stderr_capture_maxbytes&#x3D;1MB   ; number of bytes in &#39;capturemode&#39; (default 0);stderr_events_enabled&#x3D;false   ; emit events on stderr writes (default false);stderr_syslog&#x3D;false           ; send stderr to syslog with process name (default false);environment&#x3D;A&#x3D;&quot;1&quot;,B&#x3D;&quot;2&quot;       ; process environment additions (def no adds);serverurl&#x3D;AUTO                ; override serverurl computation (childutils); The sample eventlistener section below shows all possible eventlistener; subsection values.  Create one or more &#39;real&#39; eventlistener: sections to be; able to handle event notifications sent by supervisord.;[eventlistener:theeventlistenername];command&#x3D;&#x2F;bin&#x2F;eventlistener    ; the program (relative uses PATH, can take args);process_name&#x3D;%(program_name)s ; process_name expr (default %(program_name)s);numprocs&#x3D;1                    ; number of processes copies to start (def 1);events&#x3D;EVENT                  ; event notif. types to subscribe to (req&#39;d);buffer_size&#x3D;10                ; event buffer queue size (default 10);directory&#x3D;&#x2F;tmp                ; directory to cwd to before exec (def no cwd);umask&#x3D;022                     ; umask for process (default None);priority&#x3D;-1                   ; the relative start priority (default -1);autostart&#x3D;true                ; start at supervisord start (default: true);startsecs&#x3D;1                   ; # of secs prog must stay up to be running (def. 1);startretries&#x3D;3                ; max # of serial start failures when starting (default 3);autorestart&#x3D;unexpected        ; autorestart if exited after running (def: unexpected);exitcodes&#x3D;0                   ; &#39;expected&#39; exit codes used with autorestart (default 0);stopsignal&#x3D;QUIT               ; signal used to kill process (default TERM);stopwaitsecs&#x3D;10               ; max num secs to wait b4 SIGKILL (default 10);stopasgroup&#x3D;false             ; send stop signal to the UNIX process group (default false);killasgroup&#x3D;false             ; SIGKILL the UNIX process group (def false);user&#x3D;chrism                   ; setuid to this UNIX account to run the program;redirect_stderr&#x3D;false         ; redirect_stderr&#x3D;true is not allowed for eventlisteners;stdout_logfile&#x3D;&#x2F;a&#x2F;path        ; stdout log path, NONE for none; default AUTO;stdout_logfile_maxbytes&#x3D;1MB   ; max # logfile bytes b4 rotation (default 50MB);stdout_logfile_backups&#x3D;10     ; # of stdout logfile backups (0 means none, default 10);stdout_events_enabled&#x3D;false   ; emit events on stdout writes (default false);stdout_syslog&#x3D;false           ; send stdout to syslog with process name (default false);stderr_logfile&#x3D;&#x2F;a&#x2F;path        ; stderr log path, NONE for none; default AUTO;stderr_logfile_maxbytes&#x3D;1MB   ; max # logfile bytes b4 rotation (default 50MB);stderr_logfile_backups&#x3D;10     ; # of stderr logfile backups (0 means none, default 10);stderr_events_enabled&#x3D;false   ; emit events on stderr writes (default false);stderr_syslog&#x3D;false           ; send stderr to syslog with process name (default false);environment&#x3D;A&#x3D;&quot;1&quot;,B&#x3D;&quot;2&quot;       ; process environment additions;serverurl&#x3D;AUTO                ; override serverurl computation (childutils); The sample group section below shows all possible group values.  Create one; or more &#39;real&#39; group: sections to create &quot;heterogeneous&quot; process groups.;[group:thegroupname];programs&#x3D;progname1,progname2  ; each refers to &#39;x&#39; in [program:x] definitions;priority&#x3D;999                  ; the relative start priority (default 999); The [include] section can just contain the &quot;files&quot; setting.  This; setting can list multiple files (separated by whitespace or; newlines).  It can also contain wildcards.  The filenames are; interpreted as relative to this file.  Included files *cannot*; include files themselves.[include]files &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf</code></pre><p>4、编辑 supervisor 对于 isso 的专属配置文件</p><pre><code class="hljs bash">vim /etc/supervisor/conf.d/isso.conf</code></pre><p><strong>isso.conf</strong> 文件的内容如下：</p><pre><code class="hljs plain">[program:isso]command&#x3D;&#x2F;usr&#x2F;local&#x2F;isso&#x2F;bin&#x2F;isso -c &#x2F;etc&#x2F;isso.conf rundirectory&#x3D;&#x2F;var&#x2F;lib&#x2F;issouser&#x3D;rootautorestart&#x3D;truestdout_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;isso&#x2F;access.logstderr_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;isso&#x2F;error.logloglevel&#x3D;infoenvironment&#x3D;LANG&#x3D;&quot;en_US.UTF-8&quot;</code></pre><p>5、启动 supervisord 服务</p><pre><code class="hljs bash">supervisord -c /etc/supervisor/supervisord.conf</code></pre><p>6、管理 supervisor 中的 isso</p><p><strong>启动</strong>: <code>supervisorctl start isso</code></p><p><strong>重启</strong>: <code>supervisorctl restart isso</code></p><p><strong>停止</strong>: <code>supervisorctl stop isso</code></p><h2 id="访问-isso-服务"><a href="#访问-isso-服务" class="headerlink" title="访问 isso 服务"></a>访问 isso 服务</h2><pre><code class="hljs bash">curl http://localhost:5000/isso</code></pre><h2 id="修改-hexo-下-icarus-主题"><a href="#修改-hexo-下-icarus-主题" class="headerlink" title="修改 hexo 下 icarus 主题"></a>修改 hexo 下 icarus 主题</h2><p>1、增加 isso.css 样式表文件</p><pre><code class="hljs bash">vim themes/icarus/<span class="hljs-built_in">source</span>/css/isso.css</code></pre><p><strong>isso.css</strong> 文件的内容如下：</p><pre><code class="hljs plain">#isso-thread h4 &#123;    margin: 1em 0;    font-weight: bold;    font-size: 1.5em;&#125;.isso-postbox &gt; .form-wrapper &gt; .textarea-wrapper &gt; .textarea &#123;    width: 100%;    height: auto;    min-height: 8em;    overflow-y: scroll;    resize: none;    outline: none;    -webkit-user-modify: read-write-plaintext-only;&#125;.isso-postbox &gt; .form-wrapper &gt; .auth-section &#123;    width: 100%;    height: 3rem;    display: -webkit-flex;    display: flex;    justify-content: space-between;    margin: .6rem 0;&#125;.isso-postbox &gt; .form-wrapper &gt; .auth-section p &#123;    flex: 1;&#125;.isso-postbox &gt; .form-wrapper &gt; .auth-section &gt; .input-wrapper &#123;    margin-right: .6rem;&#125;.isso-postbox &gt; .form-wrapper &gt; .auth-section &gt; p &gt; input &#123;    width: 100%;    height: 100%;    display: block;    padding: .6rem .8rem;    font-size: 14px;    border-radius: .2rem;    outline: none;&#125;.isso-postbox &gt; .form-wrapper &gt; .auth-section &gt; .input-wrapper  input &#123;    background: #fafafa;    border: .1rem solid #eee;    cursor: text;&#125;.isso-postbox &gt; .form-wrapper &gt; .auth-section &gt; .post-action  input &#123;    background: #2687fb;    border: .1rem solid #177ffb;    color: #fff;    cursor: pointer;&#125;.isso-postbox &gt; .form-wrapper &gt; .notification-section input &#123;    margin-right: .3rem;&#125;#isso-root .isso-comment &#123;    max-width: 68em;    padding-top: 0.95em;    margin: 0.95em auto;&#125;.isso-comment &gt; div.avatar &#123;    display: block;    float: left;    width: 7%;    margin: 3px 15px 0 0;&#125;.isso-comment &gt; div.avatar &gt; svg &#123;    max-width: 48px;    max-height: 48px;    border: 1px solid rgba(0, 0, 0, 0.2);    border-radius: 3px;    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);&#125;.isso-comment &gt; div.text-wrapper &#123;    display: block;&#125;.isso-comment .isso-follow-up &#123;    padding-left: calc(7% + 20px);&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header, .isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer &#123;    font-size: 0.95em;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header &#123;    font-size: 0.85em;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header .spacer &#123;    padding: 0 6px;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header .spacer,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header a.permalink,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header .note,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header a.parent &#123;    color: gray !important;    font-weight: normal;    text-shadow: none !important;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header .spacer:hover,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header a.permalink:hover,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header .note:hover,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header a.parent:hover &#123;    color: #606060 !important;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header .note &#123;    float: right;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-header .author &#123;    font-weight: bold;    color: #555;&#125;.isso-comment &gt; div.text-wrapper &gt; .textarea-wrapper .textarea,.isso-comment &gt; div.text-wrapper &gt; .textarea-wrapper .preview &#123;    margin-top: 0.2em;&#125;.isso-comment &gt; div.text-wrapper &gt; div.text p &#123;    margin-top: 0.2em;&#125;.isso-comment &gt; div.text-wrapper &gt; div.text p:last-child &#123;    margin-bottom: 0.2em;&#125;.isso-comment &gt; div.text-wrapper &gt; div.text h1,.isso-comment &gt; div.text-wrapper &gt; div.text h2,.isso-comment &gt; div.text-wrapper &gt; div.text h3,.isso-comment &gt; div.text-wrapper &gt; div.text h4,.isso-comment &gt; div.text-wrapper &gt; div.text h5,.isso-comment &gt; div.text-wrapper &gt; div.text h6 &#123;    font-size: 130%;    font-weight: bold;&#125;.isso-comment &gt; div.text-wrapper &gt; div.textarea-wrapper .textarea,.isso-comment &gt; div.text-wrapper &gt; div.textarea-wrapper .preview &#123;    width: 100%;    border: 1px solid #f0f0f0;    border-radius: 2px;    box-shadow: 0 0 2px #888;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer &#123;    font-size: 0.80em;    color: gray !important;    clear: left;&#125;.isso-feedlink,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer a &#123;    font-weight: bold;    text-decoration: none;&#125;.isso-feedlink:hover,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer a:hover &#123;    color: #111111 !important;    text-shadow: #aaaaaa 0 0 1px !important;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer &gt; a &#123;    position: relative;    top: .2em;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer &gt; a + a &#123;    padding-left: 1em;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer .votes &#123;    color: gray;&#125;.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer .upvote svg,.isso-comment &gt; div.text-wrapper &gt; .isso-comment-footer .downvote svg &#123;    position: relative;    top: .2em;&#125;.isso-comment .isso-postbox &#123;    margin-top: 0.8em;&#125;.isso-comment.isso-no-votes span.votes &#123;    display: none;&#125;</code></pre><p>2、修改 isso.ejs 这一 isso 布局文件</p><pre><code class="hljs bash">vim themes/icarus/layout/comment/isso.ejs</code></pre><p><strong>isso.ejs</strong> 文件的内容如下：</p><pre><code class="hljs plain">&lt;% if (!has_config(&#39;comment.url&#39;)) &#123; %&gt;&lt;div class&#x3D;&quot;notification is-danger&quot;&gt;    You forgot to set the &lt;code&gt;url&lt;&#x2F;code&gt; for Isso. Please set it in &lt;code&gt;_config.yml&lt;&#x2F;code&gt;.&lt;&#x2F;div&gt;&lt;% &#125; else &#123; %&gt;&lt;%- _css(&#39;css&#x2F;isso&#39;) %&gt;&lt;script data-isso&#x3D;&quot;&#x2F;&#x2F;&lt;%&#x3D; get_config(&#39;comment.url&#39;) %&gt;&quot;    data-isso-css&#x3D;&quot;false&quot;    data-isso-lang&#x3D;&quot;zh&quot;    data-isso-reply-to-self&#x3D;&quot;true&quot;    data-isso-require-author&#x3D;&quot;true&quot;    data-isso-reply-notifications&#x3D;&quot;true&quot;    src&#x3D;&quot;&#x2F;&#x2F;&lt;%&#x3D; get_config(&#39;comment.url&#39;) %&gt;&#x2F;js&#x2F;embed.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;section id&#x3D;&quot;isso-thread&quot; data-title&#x3D;&quot;&lt;%&#x3D; post.title %&gt;&quot;&gt;&lt;&#x2F;section&gt;&lt;% &#125; %&gt;</code></pre><p>3、修改 icarus 主题的 _config.yml 文件，添加 isso 的相关配置 (<a href="https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Comment/" target="_blank" rel="noopener">文档</a>)</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>Python3</tag>
      
      <tag>Isso</tag>
      
      <tag>Node</tag>
      
      <tag>Supervisor</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Airserver的Huawei手机简易投屏直播服务搭建过程全记录</title>
    <link href="/2019/10/22/Huawei-mirror-live/"/>
    <url>/2019/10/22/Huawei-mirror-live/</url>
    
    <content type="html"><![CDATA[<p>2019 年 7 月 2 日，是一个令无数跑跑卡丁车端游老玩家为之兴奋的日子，腾讯游戏联合世纪天成推出了跑跑的手游并正式开服，开服前的预约人数就已经突破了 2000 万。作为一个当年端游的死忠粉，当然也要赶上这波热潮。到今天为止，跑跑手游已经运营了快四个月了，这期间推出了无数的人物和赛车，上新的速度远超氪金的速度括弧笑。喜欢玩游戏的朋友应该大多有为了体验新人物、新道具或者帮人上分而使用好友账号登陆的经历，这不，贫穷的我想用一个土豪朋友的号体验一下新出的光明骑士。</p><p>腾讯为游戏划分了微信、QQ、苹果、安卓四种区服，我的土豪朋友是在安卓微信区，那么我需要使用微信登陆上他的游戏账号。说到微信登陆，真的是既方便又不方便，方便的是它提供了扫码登录的功能，朋友不需要告知我他的用户名和密码便可以安全的让我登录上他的账号。不方便的地方是，游戏必须在没有检测到设备已安装微信 app 的情况下才会提供扫码登录的功能，而且据说从微信 7.0 版本开始，截图用于登录的二维码再从相册导入截图的扫码方法已经失效，只能当面扫一扫。然鹅我和我的土豪朋友相隔一千多公里，为了解决这一问题，有了下面的一大波踩坑和填坑的辛酸泪。</p><a id="more"></a><p><strong>我的设备：1 台 Huawei Mate10 Pro手机，1 台 Mac 电脑，1 台闲置的服务器。</strong></p><p>为了实现远距离的扫码登录，参考各大直播平台主播代练的方法，我决定也使用直播这种方式来完成这波操作。但问题是<strong>贫穷</strong>限制了我只有一台手机，并且已经安装了微信 app ，如何在不删除现有微信的情况下建立一个没有微信 app 的环境成为一个问题；并且我也不想为此就去某个平台注册一个主播号，因为太麻烦，那只能自己手动搭建一个直播环境了。<strong>大致的思路就是：利用一个独立的无微信的空间，在其中安装跑跑手游 app 并打开二维码登录界面，将手机投屏到我的 Mac 电脑端，通过 OBS 工具推流到服务器，我的好友访问对应的直播地址进行观看并扫码。</strong>思路大概有了，那么就去实践一下吧。</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/vaylf.png!origin" srcset="/img/loading.gif" alt=""></p><h2 id="填坑一：在一台手机上建立有微信-app-和没有微信-app-的两种环境"><a href="#填坑一：在一台手机上建立有微信-app-和没有微信-app-的两种环境" class="headerlink" title="填坑一：在一台手机上建立有微信 app 和没有微信 app 的两种环境"></a>填坑一：在一台手机上建立有微信 app 和没有微信 app 的两种环境</h2><ul><li><strong>方法 1 **：不知什么时候开始，时常能在小红书、抖音、微博上看到大吹华为手机自带的</strong>隐私空间<strong>功能的短视频，官方介绍为：隐私空间是一个可存储私人数据、</strong>独立**于主空间的私密空间。面对第一个问题，我第一反应便是这个。具体的开启路径为 [设置] -&gt; [安全和隐私] -&gt; [隐私空间] -&gt; [开启] 。</li></ul><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/kc7j7.jpg!origin" srcset="/img/loading.gif" alt="华为隐私空间"></p><ul><li><strong>方法 2 **：当然，创建另一个独立空间的方法肯定不止隐私空间这一种，另一个可行的方法是，利用华为的</strong>多账户功能**。具体设置路径为 [设置] -&gt; [用户和账户] -&gt; [多用户] -&gt; [添加用户] 。</li></ul><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/o8iif.png!origin" srcset="/img/loading.gif" alt="华为多账户"></p><p>新建账户之后需要进行设置，跳过网络连接的步骤便无需登录华为账户，设置完成后，可以通过点击通知栏上方的头像切换回主账户。</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/xxh0u.png!origin" srcset="/img/loading.gif" alt="账户切换1"></p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/4naij.png!origin" srcset="/img/loading.gif" alt="账户切换2"></p><h2 id="填坑二：将华为手机投屏到-Mac-端"><a href="#填坑二：将华为手机投屏到-Mac-端" class="headerlink" title="填坑二：将华为手机投屏到 Mac 端"></a>填坑二：将华为手机投屏到 Mac 端</h2><p>这里采用一个牛逼的工具 —— <a href="https://www.airserver.com/Mac" target="_blank" rel="noopener"><strong>AirServer for MacOS</strong></a> 。</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/6x4ub.png!origin" srcset="/img/loading.gif" alt="AirServer-logo"></p><p>引用官方的介绍：AirServer is the most advanced screen mirroring receiver for Mac and PC. It allows you to receive AirPlay and Google Cast streams, similar to an Apple TV or a Chromecast device.</p><p>AirServer 是一款收费软件，Mac 版有三个价格，当然也可以免费试用 14 天：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/b8457.png!origin" srcset="/img/loading.gif" alt="AirServer for MacOS 价格"></p><p>网上有很多的破解版，不过还是建议大家购买正版，支持一下这款非常优秀的软件，我先买为敬。(官方支持信用卡及 PayPal 付款)</p><p>AirServer for MacOS 并没有可视化的主界面，只有设置界面：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/6mfnj.png!origin" srcset="/img/loading.gif" alt="AirServer 设置界面截图"></p><p>这里几乎无需设置，只需要设置一下计算机名称便可直接使用。</p><p>电脑端配置完成，还需要手机的连接才行。苹果手机用自带的 AirPlay 便可以直接投屏到 Mac 端，而安卓手机需要额外使用的应用。这里使用官方的 <a href="https://play.google.com/store/apps/details?id=com.appdynamic.airserverconnect&hl=en" target="_blank" rel="noopener">AirServer Connect</a> 或者 Google 推出的 <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.chromecast.app&hl=en" target="_blank" rel="noopener">Google Home</a> 两个应用程序进行连接，它们都需要从 Google Play 商店进行下载。</p><blockquote><p><strong>基本连接环境：手机与电脑需要处于同一个 Wi-Fi 环境下。</strong></p></blockquote><h3 id="AirServer-Connect-连接方法"><a href="#AirServer-Connect-连接方法" class="headerlink" title="AirServer Connect 连接方法"></a>AirServer Connect 连接方法</h3><p>1、点击 Mac 端最上方菜单栏中 AirServer 的图标，选择  <code>Show QR Code</code> 选项，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/yu73v.png!origin" srcset="/img/loading.gif" alt="打开 AirServer 连接二维码"></p><p>2、打开手机端的 AirServer Connect 应用程序，点击上方的二维码图标，扫码 Mac 端二维码进行连接，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/8tv19.png!origin" srcset="/img/loading.gif" alt="AirServer Connect 扫码连接"></p><p>当然，如果知道 Mac 端的局域网地址，也可以在 AirServer Connect 应用程序右上角的菜单栏中点击<code>连接到...</code> ，输入 Mac 端的局域网地址进行快速连接，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/2b3v0.png!origin" srcset="/img/loading.gif" alt="选择&quot;连接到...&quot;选项"></p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/j0whs.png!origin" srcset="/img/loading.gif" alt="输入 Mac 端地址"></p><p>连接完成后，Mac 端会弹出手机投屏的对话框，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/utal0.png!origin" srcset="/img/loading.gif" alt="AirServer Connect 连接成功"></p><h3 id="Google-Home-连接方法"><a href="#Google-Home-连接方法" class="headerlink" title="Google Home 连接方法"></a>Google Home 连接方法</h3><p>1、在 Mac 端的 AirServer 设置中勾选 <code>Enable Google Cast</code> ，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/5ubdf.png!origin" srcset="/img/loading.gif" alt=""></p><p>2、打开 Google Home 应用程序，切换到最后的<img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/y7s6z.png!origin" srcset="/img/loading.gif" alt=""><code>账户信息</code>标签页；</p><p>3、向下滑动选择<code>镜像设备内容</code>选项，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/3lzvi.png!origin" srcset="/img/loading.gif" alt=""></p><p>4、进入镜像设备内容后，点击<code>投射屏幕/音频</code>按钮，程序会自动搜索同一局域网络下支持投射的设备，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/luuvu.png!origin" srcset="/img/loading.gif" alt=""></p><p>5、选择要投射到的设备，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/rq5mj.png!origin" srcset="/img/loading.gif" alt=""></p><h3 id="两种投屏方式比较"><a href="#两种投屏方式比较" class="headerlink" title="两种投屏方式比较"></a>两种投屏方式比较</h3><p>1、投屏功能：二者都能够将手机画面投射到 Mac 端，但出于谷歌某些安全机制原因，AirServer Connect 无法将手机设备的声音也投射过去，而 Google Home 可以，具体原因如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/3vzek.png!origin" srcset="/img/loading.gif" alt="AirServer Connect 无法投射声音原因"></p><p>2、投屏效率：作为 AirServer 官方出品的手机客户端，AirServer Connect 当然能够更高效地将画面投射到客户端，而 AirServer 同样兼容的 Google Cast 功能则效率相对会低一点，在打开 Goolge Home 的投屏功能时，该应用程序也会弹出一个提示框，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/jtck5.png!origin" srcset="/img/loading.gif" alt="Google Cast设备未优化警告"></p><p>这种情况下，经过实测，画面可能会有少许掉帧，没有 AirServer Connect 那么流畅，但是能将声音投射给 Mac 端，还是能接受的。</p><h2 id="踩坑一：AirServer-Connect-连接-Mac-端后一分钟内连接会自动断开"><a href="#踩坑一：AirServer-Connect-连接-Mac-端后一分钟内连接会自动断开" class="headerlink" title="踩坑一：AirServer Connect 连接 Mac 端后一分钟内连接会自动断开"></a>踩坑一：AirServer Connect 连接 Mac 端后一分钟内连接会自动断开</h2><p>这是由于华为手机自带的手机管家默认对应用启动权限进行了自动托管，只需要对 AirServer Connect 这一应用关闭自动托管功能就好，具体操作方法为：[手机管家] -&gt; [应用启动管理] -&gt; [将 AirServer Connect 后的开关拨至手动管理状态] -&gt; [在弹出的窗口中将三个开关都拨至打开状态]。如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/y82pj.png!origin" srcset="/img/loading.gif" alt=""></p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/6wbgx.png!origin" srcset="/img/loading.gif" alt=""></p><p>这样，AirServer Connect 应用程序就能保持在后台运行不会被安卓系统自动回收了。</p><h2 id="踩坑二：华为手机子账户或隐私空间中不可管理应用启动权限"><a href="#踩坑二：华为手机子账户或隐私空间中不可管理应用启动权限" class="headerlink" title="踩坑二：华为手机子账户或隐私空间中不可管理应用启动权限"></a>踩坑二：华为手机子账户或隐私空间中不可管理应用启动权限</h2><p>在华为手机的子账户或隐私空间中，手机管家这一应用程序中，只有流量管理和电池管理两个选项，其余部分都无法进入，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/ozaap.png!origin" srcset="/img/loading.gif" alt=""></p><p>解决方法：进入主账户的手机管家中进行设置，<strong>子账户中的权限将与主账户中设置的同步</strong>。</p><blockquote><p>注意：<strong>请使用华为子账户而非隐私空间</strong>，经测试，隐私空间中应用的权限极低，并且不与主账户中设置的权限同步。</p></blockquote><hr><p>华为手机投屏的坑都踩的差不多了，下面该介绍一下简单的直播服务的搭建过程了。</p><h2 id="NGINX-服务器程序的编译与安装"><a href="#NGINX-服务器程序的编译与安装" class="headerlink" title="NGINX 服务器程序的编译与安装"></a>NGINX 服务器程序的编译与安装</h2><blockquote><p>官方介绍：nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by <a href="http://sysoev.ru/en/" target="_blank" rel="noopener">Igor Sysoev</a>.</p></blockquote><p>为了实现高质量低延迟的实时在线直播功能，决定采用 rtmp 协议，并为 nginx 添加 rtmp 插件，这里采用开源的 nginx-rtmp-module 插件，GitHub 地址：<a href="https://github.com/arut/nginx-rtmp-module。" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module。</a></p><p>为了给 nginx 安装上 rtmp 插件，需要将 nginx 从源码编译，并在参数中添加上 rtmp 模块。以 CentOS 7 系统为例：</p><ul><li><p>更新 yum 仓库并安装必要工具：</p><pre><code class="hljs bash">yum -y update &amp;&amp; yum install -y wget git make automake autoconf gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel libtool</code></pre></li><li><p>下载 nginx 源码并克隆 nginx-rtmp-module 仓库，编译安装：</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp &amp;&amp; git <span class="hljs-built_in">clone</span> https://github.com/arut/nginx-rtmp-module.git \&amp;&amp; wget http://nginx.org/download/nginx-1.16.1.tar.gz \    &amp;&amp; tar -zxvf nginx-1.16.1.tar.gz \    &amp;&amp; <span class="hljs-built_in">cd</span> nginx-1.16.1 \    &amp;&amp; mkdir -p /usr/<span class="hljs-built_in">local</span>/nginx \    &amp;&amp; ./configure --prefix=/usr/<span class="hljs-built_in">local</span>/nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --add-module=/nginx-rtmp-module \    &amp;&amp; make &amp;&amp; make install \    &amp;&amp; <span class="hljs-built_in">cd</span> /tmp &amp;&amp; rm -rf nginx-rtmp-module nginx-1.16.1 nginx-1.16.1.tar.gz</code></pre></li></ul><p>这样就成功安装了支持 rtmp 的 nginx 服务器程序。</p><h2 id="NGINX-的配置"><a href="#NGINX-的配置" class="headerlink" title="NGINX 的配置"></a>NGINX 的配置</h2><p>配置文件路径为 nginx 根目录下 conf/nginx.conf 。</p><p>在该文件中添加 rtmp 部分的配置，最简单的配置内容如下：</p><pre><code class="hljs plain">rtmp &#123;    server &#123;        listen 1935;  # 默认监听端口        chunk_size 4000;  # 默认数据传输块大小        application live &#123;  # application后的名称为rtmp推流的请求路径            live on;  # 开启直播        &#125;    &#125;&#125;</code></pre><p>有了以上配置，在启动 nginx 服务器后就可以通过支持 rtmp 流的播放器查看直播内容了，或者使用 ffplay 直接播放，地址为：<code>rtmp://&lt;IP&gt;:1935/live</code> ，播放命令为：<code>ffplay -i &quot;rtmp://&lt;IP&gt;:1935/live&quot;</code> 。</p><p>对于一些移动端的朋友，可能这样收看直播并不方便，更为直观和简便的方法是在网页中嵌入一个播放器，在此播放器中播放直播的媒体流。最简单的方案是开启 hls 支持，那么我们就为 nginx 添加相关配置。</p><pre><code class="hljs plain">rtmp &#123;    server &#123;        listen 1935;        chunk_size 4000;        application live &#123;            live on;            hls on;  # 开启hls            hls_path html&#x2F;hls;  # 切片文件存放路径            hls_fragment 5s;  # 每个切片文件包含的视频时长为5秒            hls_playlist_length 15s;  # hls播放列表的长度            hls_continuous on;  # 连续模式            hls_cleanup on;  # 对多余的切片进行删除            hls_nested on;  # 嵌套模式        &#125;    &#125;&#125;</code></pre><p>为了能够以 http 协议获取 hls ，还需要在配置文件的 http 模块下添加如下的配置：</p><pre><code class="hljs plain">server &#123;    listen 8888;    server_name localhost;    location &#x2F;player &#123;        alias &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;;  # 嵌入播放器的html文件路径        index player.html;    &#125;    location &#x2F;hls-live &#123;        alias &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;hls&#x2F;;  # 切片文件路径        types &#123;            application&#x2F;vnd.apple.mpegurl m3u8;            video&#x2F;mp2t ts;        &#125;        expires -1;        add_header Cache-Control no-cache;        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;        add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;        add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;    &#125;&#125;</code></pre><p>完整的 <code>nginx.conf</code> 文件内容：</p><pre><code class="hljs plain">#user  nobody;worker_processes  1;#error_log  logs&#x2F;error.log;#error_log  logs&#x2F;error.log  notice;#error_log  logs&#x2F;error.log  info;#pid        logs&#x2F;nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs&#x2F;access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    gzip  on;    server &#123;        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs&#x2F;host.access.log  main;        location &#x2F; &#123;            root   html;            index  index.html index.htm;        &#125;        #error_page  404              &#x2F;404.html;        # redirect server error pages to the static page &#x2F;50x.html        #        error_page   500 502 503 504  &#x2F;50x.html;        location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ &#123;        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;        #&#125;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ &#123;        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;        #    include        fastcgi_params;        #&#125;        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ &#x2F;\.ht &#123;        #    deny  all;        #&#125;    &#125;    server &#123;        listen 8888;        server_name localhost;        location &#x2F;player &#123;            alias &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;;            index player.html;        &#125;        location &#x2F;hls-live &#123;            alias &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;hls&#x2F;;            types &#123;                application&#x2F;vnd.apple.mpegurl m3u8;                video&#x2F;mp2t ts;            &#125;            expires -1;            add_header Cache-Control no-cache;            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;        &#125;    &#125;    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server &#123;    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location &#x2F; &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;    # HTTPS server    #    #server &#123;    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location &#x2F; &#123;    #        root   html;    #        index  index.html index.htm;    #    &#125;    #&#125;&#125;rtmp &#123;    server &#123;        listen 1935;        chunk_size 4000;        application live &#123;            live on;            hls on;            hls_path html&#x2F;hls;            hls_fragment 5s;            hls_playlist_length 15s;            hls_continuous on;            hls_cleanup on;            hls_nested on;        &#125;    &#125;&#125;</code></pre><h2 id="编写支持-hls-流媒体播放的静态-html-页面"><a href="#编写支持-hls-流媒体播放的静态-html-页面" class="headerlink" title="编写支持 hls 流媒体播放的静态 html 页面"></a>编写支持 hls 流媒体播放的静态 html 页面</h2><p>如上面 nginx.conf 中的配置，在 <code>/usr/local/nginx/html/</code> 路径下创建 <code>player.html</code> 文件。这里采用 <strong><code>video.js</code></strong> 以播放 hls 流，文件内容如下：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Live Stream<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.bootcss.com/video.js/7.6.5/video-js.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcss.com/video.js/7.6.5/video.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcss.com/videojs-contrib-hls/5.15.0/videojs-contrib-hls.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span>            html, body &#123;                width: 100%;                height: 100%;                margin: 0 auto;            &#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"live-video"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 100%; height: 100%;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"video-js vjs-default-skin vjs-big-play-centered"</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">""</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://&lt;IP&gt;:8888/hls-live/index.m3u8"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"application/x-mpegURL"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">            <span class="hljs-keyword">var</span> player = videojs(<span class="hljs-string">'live-video'</span>);</span>            player.play();        <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="NGINX-的启动、停止、重新加载"><a href="#NGINX-的启动、停止、重新加载" class="headerlink" title="NGINX 的启动、停止、重新加载"></a>NGINX 的启动、停止、重新加载</h2><p><strong>启动</strong>：<code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></p><p><strong>停止</strong>：<code>/usr/local/nginx/sbin/nginx -s stop</code></p><p><strong>重新加载</strong>：<code>/usr/local/nginx/sbin/nginx -s reload</code></p><h2 id="CentOS-7-防火墙设置"><a href="#CentOS-7-防火墙设置" class="headerlink" title="CentOS 7 防火墙设置"></a>CentOS 7 防火墙设置</h2><p>这里使用 <code>firewall-cmd</code> 命令进行管理。</p><h3 id="firewalld-服务基本命令"><a href="#firewalld-服务基本命令" class="headerlink" title="firewalld 服务基本命令"></a>firewalld 服务基本命令</h3><p><strong>启动</strong>：<code>systemctl start firewalld</code></p><p><strong>停止</strong>：<code>systemctl stop firewalld</code></p><p><strong>查看状态</strong>：<code>systemctl status firewalld</code></p><h3 id="firewall-cmd-命令基本使用"><a href="#firewall-cmd-命令基本使用" class="headerlink" title="firewall-cmd 命令基本使用"></a>firewall-cmd 命令基本使用</h3><p><strong>查看防火墙状态</strong>：<code>firewall-cmd --state</code></p><p><strong>查看防火墙所有端口情况</strong>：<code>firewall-cmd --list-all</code></p><p><strong>开启某个端口</strong>：<code>firewall-cmd --permanent --add-port=80/tcp</code></p><p><strong>关闭某个端口</strong>：<code>firewall-cmd --permanent --remove-port=80/tcp</code></p><p><strong>重载防火墙配置</strong>：<code>firewall-cmd --reload</code></p><blockquote><p>注意：在开启或关闭某个/些端口后需要重载防火墙配置才能生效。</p></blockquote><h2 id="OBS-推流设置"><a href="#OBS-推流设置" class="headerlink" title="OBS 推流设置"></a>OBS 推流设置</h2><p>打开 OBS 工具的设置界面，选择左侧的 <code>推流</code> 标签页，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/58a0a.png!origin" srcset="/img/loading.gif" alt="进行推流设置"></p><p>在右侧 <code>服务器</code> 部分填入上面 nginx.conf 中设置的 rtmp 推流地址，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/4wzri.png!origin" srcset="/img/loading.gif" alt="填入推流地址"></p><p>设置完成后，回到 OBS 主界面，添加<code>Syphon客户端</code>，选择 AirServer 的投屏窗口，然后在右侧点击 <code>开始推流</code> ，稍等片刻，刷新我们的播放器界面，便能收看到直播的内容了。</p><h2 id="关于-MAC-内录声音的问题"><a href="#关于-MAC-内录声音的问题" class="headerlink" title="关于 MAC 内录声音的问题"></a>关于 MAC 内录声音的问题</h2><p>苹果出于防盗版的考虑，并不支持 mac 的视频或者声音内录，这就需要用到一个开源神器，<a href="https://github.com/mattingalls/Soundflower" target="_blank" rel="noopener"><strong>SoundFlower</strong></a> 。</p><p>在安装完成该插件后，进入到 <code>应用程序</code> ，打开 <code>音频 MIDI 设置</code> ，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/htkob.png!origin" srcset="/img/loading.gif" alt="音频MIDI设置"></p><p>进入设置后，点击左下方的 <code>+</code> 号按钮，选择第二项 <code>多输出设备</code> ，在右侧勾选 <code>内建输出</code> 和 <code>Soundflower (2ch)</code> 选项，如图：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/fm1xt.png!origin" srcset="/img/loading.gif" alt="新建多输出设备"></p><p>这样，就可以在保持监听的同时，将 mac 内播放的声音录入，可以在使用 OBS 工具直播的同时播放音乐，增加直播的乐趣。</p>]]></content>
    
    
    <categories>
      
      <category>多媒体</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Huawei</tag>
      
      <tag>Nginx</tag>
      
      <tag>Rtmp</tag>
      
      <tag>Airserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ官方系列教程[翻译] - 3. Publish / Subscribe (Python版)</title>
    <link href="/2019/09/22/RabbitMQ-official-tutorials-3/"/>
    <url>/2019/09/22/RabbitMQ-official-tutorials-3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/qsd0i.png!origin" srcset="/img/loading.gif" alt=""><br>官方地址：<a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/tutorial-three-python.html</a></p><a id="more"></a><blockquote><h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>这篇教程假定 RabbitMQ 已经完成<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">安装</a>并且运行在 <code>localhost</code> 及标准端口 <code>5672</code> 上。如果你使用了一个不同的主机地址、端口或者凭据，则需要依此调整一下连接设置。</p></blockquote><h2 id="预先准备-1"><a href="#预先准备-1" class="headerlink" title="预先准备"></a>预先准备</h2><p>与其他 Python 教程一样，我们将使用版本号为 <a href="https://pika.readthedocs.io/en/stable/" target="_blank" rel="noopener">1.0.0</a> 的 <a href="https://pypi.python.org/pypi/pika" target="_blank" rel="noopener">Pika</a> RabbitMQ 客户端。</p><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><p>在<a href="https://www.keviny.site/2019/09/21/RabbitMQ-official-tutorials-2/">上一篇教程</a>里我们建立了一个工作队列。工作队列背后的假设是，每个任务都会被传递给一个工人。在这部分，我们会做一点完全不一样的事 – 我们会将一条消息发送给多个消费者。这种模式称为 <strong>“publish/subscribe (发布/订阅)”</strong> 。</p><p>为了说明这种模式，我们要构建一个简单的日志系统。它由两个程序组成 – 第一个程序会发出日志消息，第二个程序则接收并打印这些消息。</p><p>在我们的日志系统中，接收程序的每个运行副本都将收到消息。这样，我们就能够运行一个接收器并将日志定向到磁盘中；同时运行另一个接收器并在屏幕上查看日志。</p><p>从本质上说，发布出去的日志消息会被广播给所有的接收者。</p><h2 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h2><p>在本教程的前面部分我们向一个队列发送消息并从中接收消息。现在是时候来介绍一下 Rabbit 中完整的消息传递模型了。</p><p>让我们快速回顾一下在前面的教程中介绍过的内容：</p><ul><li><strong>producer (生产者)</strong> 是用来发送消息的用户应用程序。</li><li><strong>queue (队列)</strong> 是用来存储消息的缓存。</li><li><strong>consumer (消费者)</strong> 是用来接收消息的用户应用程序。</li></ul><p>RabbitMQ 中消息传递模型的核心思想是生产者永远不会直接将任何消息发送到队列中。实际上，生产者常常完全都不知道消息是否会被传递到一个队列中去。</p><p>相反的，生产者只能将消息发送到 <strong>exchange (交换器)</strong> 中。交换器是一个非常简单的东西。一方面，它从生产者那里接收消息，另一方面，它将消息推送到队列中去。交换器必须确切地知道该如何处理接收到的消息。是否应该将其附加到一个特定的队列中？是否应该将其附加到许多的队列中？还是应该丢弃它呢？其中的规则由 <strong>exchange type (交换器类型)</strong> 来定义。</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/41y33.webp!origin" srcset="/img/loading.gif" alt="交换器模型"></p><p>有几种可用的交换器类型：<code>direct</code>，<code>topic</code>，<code>headers</code> 和 <code>fanout</code> 。我们主要来看最后一个 – fanout 。让我们使用这种类型创建一个交换器，并称之为 <code>logs</code> ：</p><pre><code class="hljs python">channel.exchange_declare(exchange=<span class="hljs-string">'logs'</span>,                         exchange_type=<span class="hljs-string">'fanout'</span>)</code></pre><p>这种 fanout 交换器非常简单。正如你从这名字中可能会猜到的，它只是将所有它接受到的消息广播给所有它知道的队列。而这正是我们的日志记录器所需要的。</p><blockquote><h3 id="列举出交换器"><a href="#列举出交换器" class="headerlink" title="列举出交换器"></a>列举出交换器</h3><p>为了在服务器上列出交换器，你可以使用那个非常有用的工具 <code>rabbitmqctl</code> ：</p></blockquote><pre><code class="hljs bash">sudo rabbitmqctl list_exchanges</code></pre><blockquote><p>在列表中可能会有一些形如 <code>amq.*</code> 的交换器及默认(未命名)的交换器。这些是默认创建的，但此刻你可能不太需要用到。</p><h3 id="默认交换器"><a href="#默认交换器" class="headerlink" title="默认交换器"></a>默认交换器</h3><p>在本教程的前面部分我们对交换器一无所知，但仍然可以给队列发送消息。之所以可以这样是因为我们使用了一个由空字符串(<code>&quot;&quot;</code>)来标识的默认交换器。</p><p>回想一下之前我们是怎样发布消息的：</p></blockquote><pre><code class="hljs python">channel.basic_publish(exchange=<span class="hljs-string">''</span>,                      routing_key=<span class="hljs-string">'hello'</span>,                      body=message)</code></pre><blockquote><p><code>exchange</code> 参数是交换器的名称。空字符串标识的是默认或未命名的交换器：消息被路由到由 <code>routing_key</code> 指定的队列中去(如果该队列存在的话)。</p></blockquote><p>现在，我们可以改为将消息发布到命名的交换器中：</p><pre><code class="hljs python">channel.basic_publish(exchange=<span class="hljs-string">'logs'</span>,                      routing_key=<span class="hljs-string">''</span>,                      body=message)</code></pre><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>你可能还记得，之前我们使用已经指定了名称的队列(还记得 <code>hello</code> 和 <code>task_queue</code> 嘛？)。能够命名队列对我们来说是至关重要的 – 我们需要将工人指向同一个队列。当你想要在生产者和消费者之间共享队列时，给队列命名是非常重要的。</p><p>但对于我们的日志记录器来说并不是这样的。我们希望监听所有的日志消息而不仅仅是其中的一部分。我们也只对当前正在发送的消息感兴趣，而非旧的消息。为了解决这一问题我们需要两样东西。</p><p>首先，无论何时我们连接到 Rabbit ，我们都需要一个全新的空队列。为此，我们可以创建一个随机命名的队列，或者，更好的 - 让服务器为我们选择一个随机的队列名称。为此，我们可以给 <code>queue_declare</code> 提供一个空的 <code>queue</code> 参数。</p><pre><code class="hljs python">result = channel.queue_declare(queue=<span class="hljs-string">''</span>)</code></pre><p>此时，<code>result.method.queue</code> 中包含了一个随机的队列名称。例如，它可能看起来像 <code>amq.gen-JzTY20BRgKO-HjmUJj0wLg</code> 。</p><p>其次，一旦消费者连接关闭，队列就应该被删除。对此有一个 <code>exclusive</code> 标志：</p><pre><code class="hljs python">result = channel.queue_declare(queue=<span class="hljs-string">''</span>, exclusive=<span class="hljs-literal">True</span>)</code></pre><p>你可以在<a href="https://www.rabbitmq.com/queues.html" target="_blank" rel="noopener">队列指南</a>上了解到更多有关 <code>exclusive</code> 标志和其他队列属性的内容。</p><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/caxhq.png!origin" srcset="/img/loading.gif" alt="绑定模型"></p><p>我们已经创建了一个 fanout 交换器和一个队列。现在我们需要告诉交换器将消息发送到我们的队列中。其中交换器和队列的关系称为绑定。</p><pre><code class="hljs python">channel.queue_bind(exchange=<span class="hljs-string">'logs'</span>,                   queue=result.method.queue)</code></pre><p>从现在起，<code>log</code> 交换器会将消息附加到我们的队列中。</p><blockquote><h3 id="列举出绑定"><a href="#列举出绑定" class="headerlink" title="列举出绑定"></a>列举出绑定</h3><p>你大概能猜到使用如下的方式列举出已经存在的绑定：</p></blockquote><pre><code class="hljs bash">rabbitmqctl list_bindings</code></pre><h2 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h2><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/0f8f9.png!origin" srcset="/img/loading.gif" alt="总体架构模型"></p><p>用于发送日志消息的生产者程序跟前面教程中的看起来没有很大的不同。其中最重要的变化是，我们现在希望将消息发布到名为 <code>log</code> 的交换器而非未命名的交换器。在发送消息时我们需要提供 <code>routing_key</code> ，但对于 <code>fanout</code> 交换，它的值将被忽略。</p><p><code>emit_log.py</code> (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/emit_log.py" target="_blank" rel="noopener">source</a>)</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-keyword">import</span> pika<span class="hljs-keyword">import</span> sysconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=<span class="hljs-string">'localhost'</span>))channel = connection.channel()channel.exchange_declare(exchange=<span class="hljs-string">'logs'</span>, exchange_type=<span class="hljs-string">'fanout'</span>)message = <span class="hljs-string">' '</span>.join(sys.argv[<span class="hljs-number">1</span>:]) <span class="hljs-keyword">or</span> <span class="hljs-string">"info: Hello World!"</span>channel.basic_publish(exchange=<span class="hljs-string">'logs'</span>, routing_key=<span class="hljs-string">''</span>, body=message)print(<span class="hljs-string">" [x] Sent %r"</span> % message)connection.close()</code></pre><p>如你所见，在建立连接之后，我们才声明了这个交换器。这一步是必要的，因为将消息发布到一个不存在的交换器是被禁止的。</p><p>如果没有队列绑定到交换器上，那么消息将会丢失，但这对于我们来说是没问题的。如果没有消费者在监听，我们可以安全地丢弃该消息。</p><p><code>receive_logs.py</code> (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive_logs.py" target="_blank" rel="noopener">source</a>)</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-keyword">import</span> pikaconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=<span class="hljs-string">'localhost'</span>))channel = connection.channel()channel.exchange_declare(exchange=<span class="hljs-string">'logs'</span>, exchange_type=<span class="hljs-string">'fanout'</span>)result = channel.queue_declare(queue=<span class="hljs-string">''</span>, exclusive=<span class="hljs-literal">True</span>)queue_name = result.method.queuechannel.queue_bind(exchange=<span class="hljs-string">'logs'</span>, queue=queue_name)print(<span class="hljs-string">' [*] Waiting for logs. To exit press CTRL+C'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>    print(<span class="hljs-string">" [x] %r"</span> % body)channel.basic_consume(    queue=queue_name, on_message_callback=callback, auto_ack=<span class="hljs-literal">True</span>)channel.start_consuming()</code></pre><p>我们完成了。如果你想将日志保存为一个文件，只需要打开一个控制台并输入：</p><pre><code class="hljs bash">python receive_logs.py &gt; logs_from_rabbit.log</code></pre><p>如果你想在屏幕上查看日志，请生成一个新的终端并运行：</p><pre><code class="hljs bash">python receive_logs.py</code></pre><p>当然，要发送日志请输入：</p><pre><code class="hljs bash">python emit_log.py</code></pre><p>使用 <code>rabbitmqctl list_bindings</code> 命令，你可以验证代码是否确切地按照我们的要求创建了绑定和队列。随着两个 <code>receive_logs.py</code> 程序的执行，你应该可以看到一些类似于这样的东西：</p><pre><code class="hljs bash">sudo rabbitmqctl list_bindings<span class="hljs-comment"># =&gt; Listing bindings ...</span><span class="hljs-comment"># =&gt; logs    exchange        amq.gen-JzTY20BRgKO-HjmUJj0wLg  queue           []</span><span class="hljs-comment"># =&gt; logs    exchange        amq.gen-vso0PVvyiRIL2WoV3i48Yg  queue           []</span><span class="hljs-comment"># =&gt; ...done.</span></code></pre><p>关于此结果的解释很简单：数据从 <code>logs</code> 交换器进入到两个由服务器分配名称的队列中。而这正是我们的意图。</p><p>想了解如何监听消息的一部分，请前往<a href="https://www.rabbitmq.com/tutorials/tutorial-four-python.html" target="_blank" rel="noopener">教程的第 4 部分</a>。</p><h2 id="生产-非-适用性免责声明"><a href="#生产-非-适用性免责声明" class="headerlink" title="生产[非]适用性免责声明"></a>生产[非]适用性免责声明</h2><p>请记住，本文或其他教程都只是教程。教程一次展示一个新的概念，并且可能会故意过度简化某些东西而忽略了其它的事物。例如，为了简洁起见，有关连接管理、错误处理、连接恢复、并发和度量收集的内容都在很大程度上被忽略了。这样简化过的代码不应该被当作是已经完成的产品。</p><p>在开发您自己的应用程序之前，请先查看<a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">文档</a>的剩余部分。我们特别推荐以下部分：<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">Publisher Confirms and Consumer Acknowledgements</a>， <a href="https://www.rabbitmq.com/production-checklist.html" target="_blank" rel="noopener">Production Checklist</a> 以及 <a href="https://www.rabbitmq.com/monitoring.html" target="_blank" rel="noopener">Monitoring</a> 。</p><h2 id="获得帮助并提供反馈"><a href="#获得帮助并提供反馈" class="headerlink" title="获得帮助并提供反馈"></a>获得帮助并提供反馈</h2><p>如果您对本教程或有关 RabbitMQ 的其他内容感到疑问，请立即在 <a href="https://groups.google.com/forum/#!forum/rabbitmq-users" target="_blank" rel="noopener">RabbitMQ mailing list</a> 上提问。</p><h2 id="帮助我们完善-3-版本以下的文档"><a href="#帮助我们完善-3-版本以下的文档" class="headerlink" title="帮助我们完善 3 版本以下的文档"></a>帮助我们完善 3 版本以下的文档</h2><p>如果你想对本网站做出改进，可以在 <a href="https://github.com/rabbitmq/rabbitmq-website" target="_blank" rel="noopener">Github</a> 上找到它的源码。只需要 fork 源仓库并提交一条 pull 请求。非常感谢！</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>Python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ官方系列教程[翻译] - 2. Work queues (Python版)</title>
    <link href="/2019/09/21/RabbitMQ-official-tutorials-2/"/>
    <url>/2019/09/21/RabbitMQ-official-tutorials-2/</url>
    
    <content type="html"><![CDATA[<p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/qsd0i.png!origin" srcset="/img/loading.gif" alt=""><br>官方地址：<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/tutorial-two-python.html</a></p><a id="more"></a><blockquote><h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>这篇教程假定 RabbitMQ 已经完成<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">安装</a>并且运行在 <code>localhost</code> 及标准端口 <code>5672</code> 上。如果你使用了一个不同的主机地址、端口或者凭据，则需要依此调整一下连接设置。</p></blockquote><h2 id="预先准备-1"><a href="#预先准备-1" class="headerlink" title="预先准备"></a>预先准备</h2><p>与其他 Python 教程一样，我们将使用版本号为 <a href="https://pika.readthedocs.io/en/stable/" target="_blank" rel="noopener">1.0.0</a> 的 <a href="https://pypi.python.org/pypi/pika" target="_blank" rel="noopener">Pika</a> RabbitMQ 客户端。</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/god0z.webp!origin" srcset="/img/loading.gif" alt="工作队列模型"></p><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><p>在<a href="https://www.keviny.site/2019/09/21/RabbitMQ-official-tutorials-1/">第一篇教程</a>里，我们写了向一个已命名的队列发送并从中接受消息的两个程序。在这篇教程里，我们将创建一个 <strong>Work Queue (工作队列)</strong> ，该队列用于在多个 <strong>workers (工人)</strong> 之间分配耗时任务。</p><p>Work Queues (工作队列)(又名：<strong>Task Queues (任务队列)</strong>)的核心思想是，避免立即执行资源密集型任务并且不得不等待它完成的情形。相反的，我们安排任务稍后再完成。我们将 <strong>task (任务)</strong> 封装成一条消息，并将它发送到队列中去。在后台运行的工人进程将抛出任务并且最终执行这项作业。当你运行了很多工人进程时，任务会在它们之间共享。</p><p>这个概念在web应用程序中尤其有用，这些应用程序无法在一个短的HTTP请求窗口期间处理一个复杂的任务。</p><p>在这系列教程的前面部分我们发送了一条包含 “Hello World!” 字符串的消息。现在我们将发送代表复杂任务的字符串。我们并没有现实世界的任务，例如要调整图片的大小或着要渲染pdf文件，因此让我们使用 <code>time.sleep()</code> 函数来使自己假装很忙。我们将字符串中点的数量当作其复杂度；每个点作为”工作”的其中一秒。举个例子，一个形如 <code>Hello...</code> 的假任务会占用 3 秒钟的时间。</p><p>我们将稍微修改一下前面例子中 <strong>send.py</strong> 的代码以允许从命令行中发送任意消息。该程序会将任务安排到我们的工作队列中，所以我们将它命名为 <code>new_task.py</code> ：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sysmessage = <span class="hljs-string">' '</span>.join(sys.argv[<span class="hljs-number">1</span>:]) <span class="hljs-keyword">or</span> <span class="hljs-string">"Hello World!"</span>channel.basic_publish(exchange=<span class="hljs-string">''</span>,                      routing_key=<span class="hljs-string">'hello'</span>,                      body=message)print(<span class="hljs-string">" [x] Sent %r"</span> % message)</code></pre><p>我们的老脚本 <strong>receive.py</strong> 也需要做一些改变：它需要将消息主体中的每一个点伪造成 1 秒钟的工作。它会从队列中抛出消息并执行任务，因此我们将它命名为 <code>worker.py</code> 。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>    print(<span class="hljs-string">" [x] Received %r"</span> % body)    time.sleep(body.count(<span class="hljs-string">b'.'</span>))    print(<span class="hljs-string">" [x] Done"</span>)</code></pre><h2 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h2><p>使用任务队列的优点之一是能够轻松地并行化工作。如果我们正在积压工作，那么我们只需要增加更多的工人，这样就可以轻松扩展了。</p><p>首先，让我们试着同时运行两个 <code>worker.py</code> 脚本。它们都会从队列中获取消息，但究竟是怎样的呢？让我们拭目以待。</p><p>你需要打开三个控制台程序。其中两个运行 <code>worker.py</code> 脚本。这些控制台程序就是我们的两个消费者 - C1 和 C2。</p><pre><code class="hljs bash"><span class="hljs-comment"># shell 1</span>python worker.py<span class="hljs-comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span></code></pre><pre><code class="hljs bash"><span class="hljs-comment"># shell 2</span>python worker.py<span class="hljs-comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span></code></pre><p>在第三个控制台程序中，我们将要发布新的任务。一旦你启动了消费者程序，你就可以发布一些消息：</p><pre><code class="hljs bash"><span class="hljs-comment"># shell 3</span>python new_task.py First message.python new_task.py Second message..python new_task.py Third message...python new_task.py Fourth message....python new_task.py Fifth message.....</code></pre><p>让我们看看传递给工人们的是什么吧：</p><pre><code class="hljs bash"><span class="hljs-comment"># shell 1</span>python worker.py<span class="hljs-comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><span class="hljs-comment"># =&gt; [x] Received 'First message.'</span><span class="hljs-comment"># =&gt; [x] Received 'Third message...'</span><span class="hljs-comment"># =&gt; [x] Received 'Fifth message.....'</span></code></pre><pre><code class="hljs bash"><span class="hljs-comment"># shell 2</span>python worker.py<span class="hljs-comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><span class="hljs-comment"># =&gt; [x] Received 'Second message..'</span><span class="hljs-comment"># =&gt; [x] Received 'Fourth message....'</span></code></pre><p>默认情况下，RabbitMQ 会按顺序将每条消息发送给下一个消费者。平均而言，每一个消费者都会接收到相同数量的消息。这种分发消息的方式称为循环。使用三个工人或更多进行尝试。</p><h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>执行任务会需要几秒钟。你可能会好奇，如果一个消费者启动了一个长耗时的任务并且在仅完成了部分任务的情况下死掉，会发生什么情况。就我们现在的代码而言，一旦 RabbitMQ 将消息传递给消费者，它会立即将这条消息标记为删除。在这种情况下，如果你杀死了一个工人，我们将会丢失其正在处理的信息。我们还会丢失所有发送给该特定工人旦尚未处理的消息。</p><p>但我们不想丢失任何任务。如果一个工人死了，我们想把任务传递给其他工人。</p><p>RabbitMQ 支持<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">消息确认</a>以确保任务永远不会丢失。消费者会发送回一条确认消息以通知 RabbitMQ 一条特定的消息已经被接收和处理，这样 RabbitMQ 就可以自由地删除这条消息。</p><p>如果一个工人死了(其通道已关闭、连接已关闭或者 TCP 连接丢失)而没有发送一条确认消息，RabbitMQ 就会知道该消息并没有被完全处理，从而将其重新放入队列中。如果同时还有其他消费者在线，它会快速的将该消息重新传递给其他消费者。这样就可以确保即使有工人偶然死亡也不会有任何消息丢失。</p><p>消息没有超时时间；当有消费者死亡时，RabbitMQ 会将消息重新传递。即使处理一条消息会花费非常漫长的时间也没关系。</p><p>默认情况下，<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">手动消息确认</a>已经打开。在前面的例子中，我们通过 <code>auto_ack=True</code> 标签显式地关闭了它们。当我们完成了一个任务时，是时候移除这个标签并让工人发送适当的确认消息了。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>    print(<span class="hljs-string">" [x] Received %r"</span> % body)    time.sleep( body.count(<span class="hljs-string">'.'</span>) )    print(<span class="hljs-string">" [x] Done"</span>)    ch.basic_ack(delivery_tag = method.delivery_tag)channel.basic_consume(queue=<span class="hljs-string">'hello'</span>, on_message_callback=callback)</code></pre><p>使用此代码，我们可以确保即使你在一个工人处理消息时使用 CTRL+C 来杀死他，也不会丢失任何东西。在工人死亡不久后，所有未经确认的消息都会被重新传递。</p><p>确认消息必须在收到消息的同一通道中发送。试图使用不同的通道进行确认将导致通道级协议的异常。请参阅<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">有关确认的文档指南</a>以了解更多信息。</p><blockquote><h3 id="忘记确认"><a href="#忘记确认" class="headerlink" title="忘记确认"></a>忘记确认</h3><p>错过 <code>basic_ack</code> 是一个常见的错误。这是个简单的错误，但后果却很严重。当你的客户端退出时，消息会被重新传递(看起来像随机传递一样)，但 RabbitMQ 会消耗越来越多的内存，因为其无法释放任何未经确认的消息。</p><p>为了调试这种错误，你可以使用 <code>rabbitmqctl</code> 来打印 <code>messages_unacknowledged</code> 字段：</p></blockquote><pre><code class="hljs bash">sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</code></pre><blockquote><p>在 Windows 平台上，去掉 sudo ：</p></blockquote><pre><code class="hljs bash">rabbitmqctl.bat list_queues name messages_ready messages_unacknowledged</code></pre><h2 id="消息持久性"><a href="#消息持久性" class="headerlink" title="消息持久性"></a>消息持久性</h2><p>我们已经学习了如何确保即使在消费者死亡的情况下，任务也不会丢失。但若 RabbitMQ 服务器停止工作，我们的任务仍然会丢失。</p><p>在 RabbitMQ 退出或崩溃时，它会丢失其中的队列和消息，除非你让它不要这样做。为了确保消息不会丢失，需要做两件事：我们需要将队列和消息都标记为持久。</p><p>首先，我们需要确保 RabbitMQ 永远不会丢失我们的队列。为了实现这一点，我们需要将此队列声明为 <strong>durable (持久)</strong> 。</p><pre><code class="hljs python">channel.queue_declare(queue=<span class="hljs-string">'hello'</span>, durable=<span class="hljs-literal">True</span>)</code></pre><p>尽管此命令本身是正确的，但在我们的设置中，它并不会生效。这是因为我们已经声明了一个名为 <code>hello</code> 但不持久的队列。RabbitMQ 不允许使用不同的参数重新定义一个现有队列，并且将向尝试进行此项操作的程序返回一个错误。但是有一个快速解决此问题的方法 - 让我们声明一个使用不同名称的队列，比如 <code>task_queue</code> ：</p><pre><code class="hljs python">channel.queue_declare(queue=<span class="hljs-string">'task_queue'</span>, durable=<span class="hljs-literal">True</span>)</code></pre><p>这个 <code>queue_declare</code> 更改需要同时应用于生产者和消费者代码。</p><p>此时，我们可以确定即使 RabbitMQ 重新启动，<code>task_queue</code> 队列也不会丢失。现在我们需要将我们的消息标记为持久消息 - 通过赋予一个值为 <code>2</code> 的 <code>delivery_mode</code> 属性。</p><pre><code class="hljs python">channel.basic_publish(exchange=<span class="hljs-string">''</span>,                      routing_key=<span class="hljs-string">"task_queue"</span>,                      body=message,                      properties=pika.BasicProperties(                         delivery_mode = <span class="hljs-number">2</span>, <span class="hljs-comment"># make message persistent</span>                      ))</code></pre><blockquote><h3 id="关于消息持久性的说明"><a href="#关于消息持久性的说明" class="headerlink" title="关于消息持久性的说明"></a>关于消息持久性的说明</h3><p>将消息标记为持久并不完全能保证消息不会丢失。尽管其告知 RabbitMQ 将消息保存到磁盘，但 RabbitMQ 接收到消息并尚未完成保存时仍会有一个短暂的时间窗口。而且，RabbitMQ 并不会对每一条消息都执行 <code>fsync(2)</code> – 它可能只是被保存到缓存中而并没有真正写入到磁盘上。持久性的保证并不强，但这对于简单的任务队列来说已经绰绰有余了。如果你需要更强有力的保证，可以使用<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">发布者确认机制</a>。</p></blockquote><h2 id="公平派遣"><a href="#公平派遣" class="headerlink" title="公平派遣"></a>公平派遣</h2><p>你可能已经注意到了，调度仍然无法完全按照我们的要求来进行。例如，在有两个工人的情况下，当所有单数消息都很庞大而双数消息都很轻量时，一个工人会一直非常忙碌，而另一个工人却几乎不做什么工作。好吧，RabbitMQ 对此一无所知，它依然只会平均分配消息。</p><p>出现这种情况的原因是，RabbitMQ 在消息进入队列的时候只是将其分配出去。它并不会查看消费者未确认消息的数量。它只会盲目地将每第 n 条消息发送给第 n 个消费者。</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/8gjj6.webp!origin" srcset="/img/loading.gif" alt="公平派遣模型"></p><p>为了克服这一问题，我们可以将 <code>basic.qos</code> 方法与 <code>prefetch_count=1</code> 设置一起使用。这会告诉 RabbitMQ 一次不要给工人一条以上的消息。换言之，在工人完成处理并确认上一条消息前不要再给它分配一条新的消息。而是将消息分配给下一个不忙的工人。</p><pre><code class="hljs python">channel.basic_qos(prefetch_count=<span class="hljs-number">1</span>)</code></pre><blockquote><h3 id="关于队列大小的说明"><a href="#关于队列大小的说明" class="headerlink" title="关于队列大小的说明"></a>关于队列大小的说明</h3><p>如果所有的工人都处于忙碌状态，你的队列就已经满了。你需要注意这一点，可能采用增加新工人的方法或着设置<a href="https://www.rabbitmq.com/ttl.html" target="_blank" rel="noopener">消息的TTL</a>。</p></blockquote><h2 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h2><p><code>new_task.py</code> (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/new_task.py" target="_blank" rel="noopener">source</a>)</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-keyword">import</span> pika<span class="hljs-keyword">import</span> sysconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=<span class="hljs-string">'localhost'</span>))channel = connection.channel()channel.queue_declare(queue=<span class="hljs-string">'task_queue'</span>, durable=<span class="hljs-literal">True</span>)message = <span class="hljs-string">' '</span>.join(sys.argv[<span class="hljs-number">1</span>:]) <span class="hljs-keyword">or</span> <span class="hljs-string">"Hello World!"</span>channel.basic_publish(    exchange=<span class="hljs-string">''</span>,    routing_key=<span class="hljs-string">'task_queue'</span>,    body=message,    properties=pika.BasicProperties(        delivery_mode=<span class="hljs-number">2</span>,  <span class="hljs-comment"># make message persistent</span>    ))print(<span class="hljs-string">" [x] Sent %r"</span> % message)connection.close()</code></pre><p><code>worker.py</code> (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/worker.py" target="_blank" rel="noopener">source</a>)</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-keyword">import</span> pika<span class="hljs-keyword">import</span> timeconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=<span class="hljs-string">'localhost'</span>))channel = connection.channel()channel.queue_declare(queue=<span class="hljs-string">'task_queue'</span>, durable=<span class="hljs-literal">True</span>)print(<span class="hljs-string">' [*] Waiting for messages. To exit press CTRL+C'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>    print(<span class="hljs-string">" [x] Received %r"</span> % body)    time.sleep(body.count(<span class="hljs-string">b'.'</span>))    print(<span class="hljs-string">" [x] Done"</span>)    ch.basic_ack(delivery_tag=method.delivery_tag)channel.basic_qos(prefetch_count=<span class="hljs-number">1</span>)channel.basic_consume(queue=<span class="hljs-string">'task_queue'</span>, on_message_callback=callback)channel.start_consuming()</code></pre><p>使用消息确认机制以及设置 <code>prefetch_count</code> 参数可以建立一个工作队列。持久化选项使得任务即使在 RabbitMQ 重启的情况下也依然能存活。</p><p><strong>是时候前往<a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" target="_blank" rel="noopener">第 3 部分</a>去学习如何将相同的消息发送给多个消费者了。</strong></p><h2 id="生产-非-适用性免责声明"><a href="#生产-非-适用性免责声明" class="headerlink" title="生产[非]适用性免责声明"></a>生产[非]适用性免责声明</h2><p>请记住，本文或其他教程都只是教程。教程一次展示一个新的概念，并且可能会故意过度简化某些东西而忽略了其它的事物。例如，为了简洁起见，有关连接管理、错误处理、连接恢复、并发和度量收集的内容都在很大程度上被忽略了。这样简化过的代码不应该被当作是已经完成的产品。</p><p>在开发您自己的应用程序之前，请先查看<a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">文档</a>的剩余部分。我们特别推荐以下部分：<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">Publisher Confirms and Consumer Acknowledgements</a>， <a href="https://www.rabbitmq.com/production-checklist.html" target="_blank" rel="noopener">Production Checklist</a> 以及 <a href="https://www.rabbitmq.com/monitoring.html" target="_blank" rel="noopener">Monitoring</a> 。</p><h2 id="获得帮助并提供反馈"><a href="#获得帮助并提供反馈" class="headerlink" title="获得帮助并提供反馈"></a>获得帮助并提供反馈</h2><p>如果您对本教程或有关 RabbitMQ 的其他内容感到疑问，请立即在 <a href="https://groups.google.com/forum/#!forum/rabbitmq-users" target="_blank" rel="noopener">RabbitMQ mailing list</a> 上提问。</p><h2 id="帮助我们完善-3-版本以下的文档"><a href="#帮助我们完善-3-版本以下的文档" class="headerlink" title="帮助我们完善 3 版本以下的文档"></a>帮助我们完善 3 版本以下的文档</h2><p>如果你想对本网站做出改进，可以在 <a href="https://github.com/rabbitmq/rabbitmq-website" target="_blank" rel="noopener">Github</a> 上找到它的源码。只需要 fork 源仓库并提交一条 pull 请求。非常感谢！</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>Python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ官方系列教程[翻译] - 1. &quot;Hello World!&quot; (Python版)</title>
    <link href="/2019/09/21/RabbitMQ-official-tutorials-1/"/>
    <url>/2019/09/21/RabbitMQ-official-tutorials-1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/qsd0i.png!origin" srcset="/img/loading.gif" alt=""><br>官方地址：<a href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html" target="_blank" rel="noopener">https://www.rabbitmq.com/tutorials/tutorial-one-python.html</a></p><a id="more"></a><blockquote><h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>这篇教程假定 RabbitMQ 已经完成<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">安装</a>并且运行在 <code>localhost</code> 及标准端口 <code>5672</code> 上。如果你使用了一个不同的主机地址、端口或者凭据，则需要依此调整一下连接设置。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>RabbitMQ是一个消息协商器(Message Broker，简称MQ)：它接受和转发消息。你可以把它当作是一个邮局：当你把想要寄出去的信件放到邮筒里时，你可以确信邮差最终会将你的信件送达你的收件人手上。在这个比喻中，RabbitMQ 就是那个邮筒、邮局以及邮差。</p><p>RabbitMQ 和邮局最主要的区别在于，RabbitMQ 处理的并不是纸质文件，而是接收、存储和转发二进制 blob 数据 - messages (消息)。</p><p>RabbitMQ 和消息传递会使用到一些专业术语。</p><ul><li><strong>Producing</strong> 指的是发送。一个负责发送消息的程序就是一个 <strong>producer</strong> ：</li></ul><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/12lv4.webp!origin" srcset="/img/loading.gif" alt="生产者"></p><ul><li><strong>Queue</strong> 是邮筒在 RabbitMQ 中的名字。尽管消息会流经 RabbitMQ 和你的程序，但它们只能被储存在一个 queue (队列)中。队列只约束于主机内存和磁盘限制，它本质上是一个大的消息缓冲区。许多的 <strong>producers</strong> (生产者)可以将消息发送到一个队列中，许多的 <strong>consumers</strong> (消费者)也可以尝试从一个队列中获取数据。我们是这样表示一个队列的：</li></ul><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/b1lfl.webp!origin" srcset="/img/loading.gif" alt="队列"></p><ul><li><strong>Consuming</strong> 和接收的意思类似。<strong>consumer</strong> (消费者)是一个主要用来等待接收消息的程序：</li></ul><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/8x9cc.webp!origin" srcset="/img/loading.gif" alt="消费者"></p><p>请注意，producer (生产者)、consumer (消费者)以及 broker (协商器)并非一定要存在于同一台主机上；实际上，在大多数的程序中，它们并没有放在一起。一个应用程序即可以是生产者，也可以是消费者。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p><strong>(使用 Python 的 Pika 客户端)</strong></p><p>在教程的这个部分，我们将要用 Python 写两个小的程序：一个生产者(发送者)程序，用来发送单条信息；以及一个消费者(接收者)程序，用来接收消息并打印。这是消息传递的”Hello World”级程序。</p><p>在下图中，”P”是我们的生产者，”C”是我们的消费者。中间的盒子是一个队列 - 即 RabbitMQ 为消费者保留的一个消息缓存。</p><p>我们的总体设计看起来像这样：</p><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/bp3u7.webp!origin" srcset="/img/loading.gif" alt="生产者、队列、消费者模型"></p><p>生产者发送消息到名为”hello”的队列中。消费者则从这个队列中接收消息。</p><blockquote><h3 id="RabbitMQ-知识库"><a href="#RabbitMQ-知识库" class="headerlink" title="RabbitMQ 知识库"></a>RabbitMQ 知识库</h3><p>RabbitMQ 使用多种协议。这篇教程使用的是 AMQP 0-9-1，这是一个开放的、通用的消息传递协议。RabbitMQ 有许多用不同语言实现的客户端。在本教程系列中，我们将要使用的是 Pika 1.0.0，这是一个由RabbitMQ团队推荐的 Python 客户端。你可以使用 <code>pip</code> 包管理工具来安装它：</p></blockquote><pre><code class="hljs bash">python -m pip install pika --upgrade</code></pre><p>现在我们的 Pika 已经安装完成了，我们可以开始写一些代码了。</p><h2 id="Sending-发送"><a href="#Sending-发送" class="headerlink" title="Sending (发送)"></a>Sending (发送)</h2><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/dvm86.webp!origin" srcset="/img/loading.gif" alt="生产者发送模型"></p><p>我们的第一个程序 <code>send.py</code> 将会发送单条消息到队列中。我们要做的第一件事情就是与 RabbitMQ 服务器建立一条连接。</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-keyword">import</span> pikaconnection = pika.BlockingConnection(pika.ConnectionParameters(<span class="hljs-string">'localhost'</span>))channel = connection.channel()</code></pre><p>我们现在已经连接上了本地机器的协商器，因此这里使用的是 <code>localhost</code> 。如果我们想要连接到另一台不同的机器上的协商器，我们只需要在这里指定它的域名或者 IP 地址。</p><p>接着，在发送消息之前，我们需要确保用于接收消息的队列确切存在。如果我们向一个不存在的位置发送了一条消息，RabbitMQ 会直接丢弃这条消息。让我们创建一个名为 <strong>hello</strong> 的队列用于发送消息：</p><pre><code class="hljs python">channel.queue_declare(queue=<span class="hljs-string">'hello'</span>)</code></pre><p>至此，我们已经准备好发送消息了。我们的第一条消息只包含一个字符串 <strong>Hello World!</strong> 并且我们想把它发送给我们的 <strong>hello</strong> 队列。</p><p>在 RabbitMQ 中，消息不能被直接发送给队列，它需要经过一个 <strong>exchange (交换器)</strong> 。但我们现在不要注意这些细节 - 你可以在<a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" target="_blank" rel="noopener">本教程系列的第三部分</a>获取更多关于 <strong>exchange (交换器)</strong> 的内容。现在我们所需要知道的只是如何使用由空字符串标识的默认交换器。这个交换器很特殊 - 它允许我们确切地指定消息要被发送到哪个队列中去。目标队列的名字需要在 <code>routing_key</code> 这个参数中指定。</p><pre><code class="hljs python">channel.basic_publish(exchange=<span class="hljs-string">''</span>,                      routing_key=<span class="hljs-string">'hello'</span>,                      body=<span class="hljs-string">'Hello World!'</span>)print(<span class="hljs-string">" [x] Sent 'Hello World!'"</span>)</code></pre><p>在退出程序之前，我们需要确保网络缓冲区被刷新并且我们的消息被确切地传递给了 RabbitMQ 。我们可以通过温柔地关闭连接来实现这一点。</p><pre><code class="hljs python">connection.close()</code></pre><blockquote><h3 id="发送失败了！"><a href="#发送失败了！" class="headerlink" title="发送失败了！"></a>发送失败了！</h3><p>如果这是你第一次使用 RabbitMQ ，并且没有看到那条 “Sent” 的输出消息，那么你可能会抓耳挠腮并好奇是哪里出了问题。有可能是协商器启动时已经没有足够可用的磁盘空间了(默认情况下它至少需要 200 MB的空闲空间)，因此它拒绝了接收消息。检查一下协商器的日志文件以确认并在必要情况下降低这个限制。<a href="https://www.rabbitmq.com/configure.html#config-items" target="_blank" rel="noopener">有关配置文件的文档</a>将会告诉你如何设置 <code>disk_free_limit</code> 。</p></blockquote><h2 id="Receiving-接收"><a href="#Receiving-接收" class="headerlink" title="Receiving (接收)"></a>Receiving (接收)</h2><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/w5kmn.webp!origin" srcset="/img/loading.gif" alt="消费者接收模型"></p><p>我们的第二个程序 <code>receive.py</code> 将要从队列中接收消息并将它们打印在屏幕上。</p><p>再一次的，我们首先要连接到 RabbitMQ 服务器。有关连接到 Rabbit 的代码跟前面是一样的。</p><p>下一步，像前面一样，需要确保目标队列确切存在。使用 <code>queue_declare</code> 来创建一个队列是幂等的 - 我们想运行这条命令多少次就可以运行多少次，因为只会创建一个队列。</p><pre><code class="hljs python">channel.queue_declare(queue=<span class="hljs-string">'hello'</span>)</code></pre><p>你可能会质问，为什么我们需要再次声明这个队列？我们已经在前面的代码中声明过了。如果我们能够确保目标队列确切存在，我们当然大可不必如此。比如我们假设 <code>send.py</code> 程序已经在前面运行过了。但是目前我们还不能确定需要先运行哪个程序。在这种情况下，在两个程序中重复地声明目标队列会是一个好的习惯。</p><blockquote><h3 id="列举出队列"><a href="#列举出队列" class="headerlink" title="列举出队列"></a>列举出队列</h3><p>你可能会想要看 RabbitMQ 中有哪些队列以及在队列中有多少消息。你可以使用 <code>rabbitmqctl</code> 工具(以被授权用户身份)来执行这个操作：</p></blockquote><pre><code class="hljs bash">sudo rabbitmqctl list_queues</code></pre><blockquote><p>在 Windows 平台上则省略 sudo ：</p></blockquote><pre><code class="hljs bash">rabbitmqctl list_queues</code></pre><p>从队列中接收消息相比之下会更复杂一些。它的工作原理是为队列订阅一个 <code>callback (回调)</code> 函数。无论何时我们收到消息，这个 <code>callback (回调)</code> 函数都会被 Pika 库调用。在这个例子中，这个函数的作用是将消息中的内容打印到屏幕上。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>    print(<span class="hljs-string">" [x] Received %r"</span> % body)</code></pre><p>接着，我们需要告诉 RabbitMQ 这个特定的回调函数应该从我们的 hello 队列中接收消息：</p><pre><code class="hljs python">channel.basic_consume(queue=<span class="hljs-string">'hello'</span>,                      auto_ack=<span class="hljs-literal">True</span>,                      on_message_callback=callback)</code></pre><p>为了使这条命令能正常工作，我们需要确保要进行订阅操作的队列确切存在。幸运的是，对此我们非常自信 - 我们在上面的部分已经使用 <code>queue_declare</code> 创建了一个队列。</p><p><code>auto_ack</code> 参数将在<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">后面部分</a>进行讨论。</p><p>最终，我们进入了一个永无止境的循环，等待数据并在必要时运行回调函数。</p><pre><code class="hljs python">print(<span class="hljs-string">' [*] Waiting for messages. To exit press CTRL+C'</span>)channel.start_consuming()</code></pre><h2 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h2><p><code>send.py</code> (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/send.py" target="_blank" rel="noopener">源文件</a>)</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-keyword">import</span> pikaconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=<span class="hljs-string">'localhost'</span>))channel = connection.channel()channel.queue_declare(queue=<span class="hljs-string">'hello'</span>)channel.basic_publish(exchange=<span class="hljs-string">''</span>, routing_key=<span class="hljs-string">'hello'</span>, body=<span class="hljs-string">'Hello World!'</span>)print(<span class="hljs-string">" [x] Sent 'Hello World!'"</span>)connection.close()</code></pre><p><code>receive.py</code> (<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/python/receive.py" target="_blank" rel="noopener">源文件</a>)</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-keyword">import</span> pikaconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=<span class="hljs-string">'localhost'</span>))channel = connection.channel()channel.queue_declare(queue=<span class="hljs-string">'hello'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>    print(<span class="hljs-string">" [x] Received %r"</span> % body)channel.basic_consume(    queue=<span class="hljs-string">'hello'</span>, on_message_callback=callback, auto_ack=<span class="hljs-literal">True</span>)print(<span class="hljs-string">' [*] Waiting for messages. To exit press CTRL+C'</span>)channel.start_consuming()</code></pre><p>现在，我们可以在终端中尝试运行我们的程序。首先，让我们启动一个消费者程序，它将持续地运行以等待”货物”。</p><pre><code class="hljs bash">python receive.py<span class="hljs-comment"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><span class="hljs-comment"># =&gt; [x] Received 'Hello World!'</span></code></pre><p>现在让我们启动生产者程序。它会在每次运行完成后便停止。</p><pre><code class="hljs bash">python send.py<span class="hljs-comment"># =&gt; [x] Sent 'Hello World!'</span></code></pre><p>欢呼吧！我们已经能够通过 RabbitMQ 发送我们的第一条消息了。你可能已经注意到了，<code>receive.py</code> 程序并没有退出。它会时刻准备着接收其他消息，直到使用 CTRL-C 组合键来停止。</p><p>在新的终端中尝试再次运行 <code>send.py</code> 程序。</p><p><strong>我们已经学习了如何向一个已经命名的队列发送消息并从中接收消息。是时候前往<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="noopener">第 2 部分</a>去学习如何建立一个简单的 work queue (工作队列)了。</strong></p><h2 id="生产-非-适用性免责声明"><a href="#生产-非-适用性免责声明" class="headerlink" title="生产[非]适用性免责声明"></a>生产[非]适用性免责声明</h2><p>请记住，本文或其他教程都只是教程。教程一次展示一个新的概念，并且可能会故意过度简化某些东西而忽略了其它的事物。例如，为了简洁起见，有关连接管理、错误处理、连接恢复、并发和度量收集的内容都在很大程度上被忽略了。这样简化过的代码不应该被当作是已经完成的产品。</p><p>在开发您自己的应用程序之前，请先查看<a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">文档</a>的剩余部分。我们特别推荐以下部分：<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">Publisher Confirms and Consumer Acknowledgements</a>， <a href="https://www.rabbitmq.com/production-checklist.html" target="_blank" rel="noopener">Production Checklist</a> 以及 <a href="https://www.rabbitmq.com/monitoring.html" target="_blank" rel="noopener">Monitoring</a> 。</p><h2 id="获得帮助并提供反馈"><a href="#获得帮助并提供反馈" class="headerlink" title="获得帮助并提供反馈"></a>获得帮助并提供反馈</h2><p>如果您对本教程或有关 RabbitMQ 的其他内容感到疑问，请立即在 <a href="https://groups.google.com/forum/#!forum/rabbitmq-users" target="_blank" rel="noopener">RabbitMQ mailing list</a> 上提问。</p><h2 id="帮助我们完善-3-版本以下的文档"><a href="#帮助我们完善-3-版本以下的文档" class="headerlink" title="帮助我们完善 3 版本以下的文档"></a>帮助我们完善 3 版本以下的文档</h2><p>如果你想对本网站做出改进，可以在 <a href="https://github.com/rabbitmq/rabbitmq-website" target="_blank" rel="noopener">Github</a> 上找到它的源码。只需要 fork 源仓库并提交一条 pull 请求。非常感谢！</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>Python3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构八大经典排序的Python实现</title>
    <link href="/2019/07/10/common-sort-algorithm/"/>
    <url>/2019/07/10/common-sort-algorithm/</url>
    
    <content type="html"><![CDATA[<p>八大排序是数据结构里最基本的知识点，也是工作中经常用到的基本算法，因此本文做以整理。</p><a id="more"></a><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint, sample<span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""冒泡排序，时间复杂度O(n^2)，空间复杂度O(1)，稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    ll = deepcopy(lst)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(ll) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):            <span class="hljs-keyword">if</span> ll[j] &gt; ll[j + <span class="hljs-number">1</span>]:                ll[j], ll[j + <span class="hljs-number">1</span>] = ll[j + <span class="hljs-number">1</span>], ll[j]    print(<span class="hljs-string">' -  冒泡排序: '</span>, ll)</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choose_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""选择排序，时间复杂度O(n^2)，空间复杂度O(1)，不稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    ll = deepcopy(lst)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(ll) - <span class="hljs-number">1</span>):        min_index = i        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i + <span class="hljs-number">1</span>, len(ll)):            <span class="hljs-keyword">if</span> ll[j] &lt; ll[min_index]:                min_index = j        ll[i], ll[min_index] = ll[min_index], ll[i]    print(<span class="hljs-string">' -  选择排序: '</span>, ll)</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""插入排序，时间复杂度O(n^2)，空间复杂度O(1)，稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    ll = deepcopy(lst)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(ll)):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):            <span class="hljs-keyword">if</span> ll[j] &lt; ll[j - <span class="hljs-number">1</span>]:                ll[j], ll[j - <span class="hljs-number">1</span>] = ll[j - <span class="hljs-number">1</span>], ll[j]            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">break</span>    print(<span class="hljs-string">' -  插入排序: '</span>, ll)</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""希尔排序，时间复杂度O(nlogn)，空间复杂度O(1)，不稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    ll = deepcopy(lst)    gap = len(ll) + <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> gap &gt; <span class="hljs-number">1</span>:        gap = gap // <span class="hljs-number">3</span> + <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gap, len(ll)):            temp = ll[i]            j = i            <span class="hljs-keyword">while</span> j &gt;= gap <span class="hljs-keyword">and</span> ll[j - gap] &gt; temp:                ll[j] = ll[j - gap]                j -= gap            ll[j] = temp    print(<span class="hljs-string">' -  希尔排序: '</span>, ll)</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""归并排序，时间复杂度O(nlogn)，空间复杂度O(n)，稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">st</span><span class="hljs-params">(l: list)</span>:</span>        arr = deepcopy(l)        <span class="hljs-keyword">if</span> len(arr) &lt; <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> arr        middle = len(arr) // <span class="hljs-number">2</span>        left = arr[:middle]        right = arr[middle:]        <span class="hljs-keyword">return</span> merge(st(left), st(right))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(left: list, right: list)</span>:</span>        result = []        <span class="hljs-keyword">while</span> left <span class="hljs-keyword">and</span> right:            <span class="hljs-keyword">if</span> left[<span class="hljs-number">0</span>] &lt;= right[<span class="hljs-number">0</span>]:                result.append(left.pop(<span class="hljs-number">0</span>))            <span class="hljs-keyword">else</span>:                result.append(right.pop(<span class="hljs-number">0</span>))        <span class="hljs-keyword">if</span> left:            result.extend(left)        <span class="hljs-keyword">if</span> right:            result.extend(right)        <span class="hljs-keyword">return</span> result    ll = st(lst)    print(<span class="hljs-string">' -  归并排序: '</span>, ll)</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""快速排序，时间复杂度O(nlogn)，空间复杂度O(logn)，不稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    ll = deepcopy(lst)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qs</span><span class="hljs-params">(l: list)</span>:</span>        <span class="hljs-keyword">if</span> len(l) &gt;= <span class="hljs-number">2</span>:            base = l[len(l) // <span class="hljs-number">2</span>]            left, right = list(), list()            l.remove(base)            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> l:                <span class="hljs-keyword">if</span> num &gt;= base:                    right.append(num)                <span class="hljs-keyword">else</span>:                    left.append(num)            <span class="hljs-keyword">return</span> qs(left) + [base] + qs(right)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> l    ll = qs(ll)    print(<span class="hljs-string">' -  快速排序: '</span>, ll)</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""堆排序，时间复杂度O(nlogn)，空间复杂度O(1)，不稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    ll = deepcopy(lst)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">big_heap</span><span class="hljs-params">(l: list, start: int, end: int)</span>:</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            lchild_index = <span class="hljs-number">2</span> * start + <span class="hljs-number">1</span>            rchild_index = <span class="hljs-number">2</span> * start + <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> lchild_index &lt; end:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">if</span> rchild_index &lt; end:                max_index = rchild_index <span class="hljs-keyword">if</span> l[rchild_index] &gt; l[lchild_index] <span class="hljs-keyword">else</span> lchild_index            <span class="hljs-keyword">else</span>:                max_index = lchild_index            <span class="hljs-keyword">if</span> l[max_index] &gt; l[start]:                l[max_index], l[start] = l[start], l[max_index]                start = max_index            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">break</span>    length = len(ll)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):        big_heap(ll, i, length)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):        ll[i], ll[<span class="hljs-number">0</span>] = ll[<span class="hljs-number">0</span>], ll[i]        big_heap(ll, <span class="hljs-number">0</span>, i)    print(<span class="hljs-string">' -    堆排序: '</span>, ll)</code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">radix_sort</span><span class="hljs-params">(lst: list)</span>:</span>    <span class="hljs-string">"""基数排序，时间复杂度O(n*k)，空间复杂度O(n+k)，稳定</span><span class="hljs-string">    :param lst: List to sort.</span><span class="hljs-string">    """</span>    ll = deepcopy(lst)    max_num = ll[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(ll)):        max_num = ll[i] <span class="hljs-keyword">if</span> ll[i] &gt; max_num <span class="hljs-keyword">else</span> max_num    loop_count, temp = <span class="hljs-number">0</span>, max_num    <span class="hljs-keyword">while</span> temp:        loop_count += <span class="hljs-number">1</span>        temp //= <span class="hljs-number">10</span>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(loop_count):        temp = [(ll[i] // (<span class="hljs-number">10</span> ** c)) % <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(ll))]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(temp)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>):                <span class="hljs-keyword">if</span> ll[j - <span class="hljs-number">1</span>] &gt; ll[j]:                    ll[j - <span class="hljs-number">1</span>], ll[j] = ll[j], ll[j - <span class="hljs-number">1</span>]                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">break</span>    print(<span class="hljs-string">' -  基数排序: '</span>, ll)</code></pre><h2 id="测试及结果"><a href="#测试及结果" class="headerlink" title="测试及结果"></a>测试及结果</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    lst = sample(list(set([randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>)])), <span class="hljs-number">10</span>)    print(<span class="hljs-string">'[+] 原始列表: '</span>, lst, <span class="hljs-string">'\n'</span>)    bubble_sort(lst)  <span class="hljs-comment"># 冒泡排序</span>    choose_sort(lst)  <span class="hljs-comment"># 选择排序</span>    insert_sort(lst)  <span class="hljs-comment"># 插入排序</span>    shell_sort(lst)  <span class="hljs-comment"># 希尔排序</span>    merge_sort(lst)  <span class="hljs-comment"># 归并排序</span>    quick_sort(lst)  <span class="hljs-comment"># 快速排序</span>    heap_sort(lst)  <span class="hljs-comment"># 堆排序</span>    radix_sort(lst)  <span class="hljs-comment"># 基数排序</span></code></pre><p><img src="https://kevin-blog-pic.oss-cn-shenzhen.aliyuncs.com/szjh4.png!unified" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
